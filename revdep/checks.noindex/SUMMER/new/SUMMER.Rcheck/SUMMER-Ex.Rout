
R version 4.3.1 (2023-06-16) -- "Beagle Scouts"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin20 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "SUMMER"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('SUMMER')
SUMMER version 1.3.0
  See latest changes with 'news(package = 'SUMMER')'
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("ChangeRegion")
> ### * ChangeRegion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ChangeRegion
> ### Title: Map region names to a common set.
> ### Aliases: ChangeRegion
> 
> ### ** Examples
> 
> 
> # Construct a small test data
> testdata <- data.frame(region = c("north", "south", "east",
+  "south", "east"), index = c(1:5))
> 
> # Construct a changing rule: combining south and east
> Bmat <- matrix(c(1, 0, 0, 0, 1, 1), 3, 2)
> colnames(Bmat) <- c("north", "south and east")
> rownames(Bmat) <- c("north", "south", "east")
> print(Bmat)
      north south and east
north     1              0
south     0              1
east      0              1
> 
> # New data after transformation
> test <- ChangeRegion(testdata, Bmat, "region")
2 names changed, in total 4 rows in data changed
> print(test)
          region index
1          north     1
2 south and east     2
3 south and east     3
4 south and east     4
5 south and east     5
> 
> 
> 
> cleanEx()
> nameEx("aggregateSurvey")
> ### * aggregateSurvey
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aggregateSurvey
> ### Title: Aggregate estimators from different surveys.
> ### Aliases: aggregateSurvey
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(DemoData)
> ##D data(DemoMap)
> ##D years <- levels(DemoData[[1]]$time)
> ##D 
> ##D # obtain direct estimates
> ##D data <- getDirectList(births = DemoData, 
> ##D years = years, 
> ##D regionVar = "region", timeVar = "time", 
> ##D clusterVar = "~clustid+id", 
> ##D ageVar = "age", weightsVar = "weights", 
> ##D geo.recode = NULL)
> ##D 
> ##D # obtain maps
> ##D geo <- DemoMap$geo
> ##D mat <- DemoMap$Amat
> ##D 
> ##D # Simulate hyper priors
> ##D priors <- simhyper(R = 2, nsamp = 1e+05, nsamp.check = 5000, Amat = mat, only.iid = TRUE)
> ##D 
> ##D # combine data from multiple surveys
> ##D data <- aggregateSurvey(data)
> ##D utils::head(data)
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("expit")
> ### * expit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expit
> ### Title: Expit transformation
> ### Aliases: expit
> 
> ### ** Examples
> 
> x <- .5
> expit(x)
[1] 0.6224593
> 
> 
> 
> 
> cleanEx()
> nameEx("getAdjusted")
> ### * getAdjusted
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getAdjusted
> ### Title: Adjust direct estimates and their associated variances
> ### Aliases: getAdjusted
> 
> ### ** Examples
> 
> ## Not run: 
> ##D years <- levels(DemoData[[1]]$time)
> ##D 
> ##D # obtain direct estimates
> ##D data <- getDirectList(births = DemoData, 
> ##D years = years,  
> ##D regionVar = "region", timeVar = "time", 
> ##D clusterVar = "~clustid+id", 
> ##D ageVar = "age", weightsVar = "weights", 
> ##D geo.recode = NULL)
> ##D # obtain direct estimates
> ##D data_multi <- getDirectList(births = DemoData, years = years,
> ##D   regionVar = "region",  timeVar = "time", clusterVar = "~clustid+id",
> ##D   ageVar = "age", weightsVar = "weights", geo.recode = NULL)
> ##D data <- aggregateSurvey(data_multi)
> ##D 
> ##D # randomly simulate adjustment factor
> ##D adj <- expand.grid(region = unique(data$region), years = years)
> ##D adj$ratio <- runif(dim(adj)[1], min = 0.5, max = 0.8)
> ##D data.adj <- getAdjusted(data = data, ratio = adj)
> ##D  
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("getAmat")
> ### * getAmat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getAmat
> ### Title: Extract adjacency matrix from the map
> ### Aliases: getAmat
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(DemoMap) 
> ##D mat <- getAmat(geo = DemoMap$geo, names = DemoMap$geo$REGNAME)
> ##D mat
> ##D DemoMap$Amat
> ## End(Not run) 
> 
> 
> 
> cleanEx()
> nameEx("getBirths")
> ### * getBirths
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getBirths
> ### Title: Reformat full birth records into person-month format
> ### Aliases: getBirths
> 
> ### ** Examples
> 
> ## Not run: 
> ##D my_fp <- "/myExampleFilepath/surveyData.DTA"
> ##D DemoData <- getBirths(filepath = my_fp, surveyyear = 2015) 
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("getCounts")
> ### * getCounts
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getCounts
> ### Title: Aggregate person-month data into counts and totals by groups.
> ### Aliases: getCounts
> 
> ### ** Examples
> 
> 
>  
> # a toy dataset with 4 time periods but one missing in data
> timelist <- factor(1:4)
> data = data.frame(died = c(0,0,0,1,1,0,0), 
+ 					area = c(rep(c("A", "B"), 3), "A"), 
+ 					time = timelist[c(1,1,2,3,3,3,3)])
> data
  died area time
1    0    A    1
2    0    B    1
3    0    A    2
4    1    B    3
5    1    A    3
6    0    B    3
7    0    A    3
> # without ignore argument, all levels will be imputed
> getCounts(data, variables = "died", by = c("area", "time"))
  area time died total
1    A    1    0     1
2    B    1    0     1
3    A    2    0     1
4    A    3    1     2
5    B    3    1     2
> 
> # ignoring time = 4, the ignored level will not be imputed (but still in the output)
> getCounts(data, variables = "died", by = c("area", "time"), 
+ 			ignore = list("time"=c(4)) )
  area time died total
1    A    1    0     1
2    B    1    0     1
3    A    2    0     1
4    A    3    1     2
5    B    3    1     2
> 
>  
> 
> 
> 
> cleanEx()
> nameEx("getDiag")
> ### * getDiag
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getDiag
> ### Title: Extract posterior summaries of random effects
> ### Aliases: getDiag
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   data(DemoMap)
> ##D   years <- levels(DemoData[[1]]$time)
> ##D   
> ##D   # obtain direct estimates
> ##D   data <- getDirectList(births = DemoData, 
> ##D   years = years,  
> ##D   regionVar = "region", timeVar = "time", 
> ##D   clusterVar = "~clustid+id", 
> ##D   ageVar = "age", weightsVar = "weights", 
> ##D   geo.recode = NULL)
> ##D   # obtain direct estimates
> ##D   data_multi <- getDirectList(births = DemoData, years = years,
> ##D     regionVar = "region",  timeVar = "time", clusterVar = "~clustid+id",
> ##D     ageVar = "age", weightsVar = "weights", geo.recode = NULL)
> ##D   data <- aggregateSurvey(data_multi)
> ##D   
> ##D   #  national model
> ##D   years.all <- c(years, "15-19")
> ##D   fit1 <- smoothDirect(data = data, geo = DemoMap$geo, Amat = DemoMap$Amat, 
> ##D     year_label = years.all, year_range = c(1985, 2019), 
> ##D     rw = 2, is.yearly=FALSE, m = 5)
> ##D random.time <- getDiag(fit1, field = "time")
> ##D   random.space <- getDiag(fit1, field = "space")
> ##D   random.spacetime <- getDiag(fit1, field = "spacetime")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("getDirect")
> ### * getDirect
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getDirect
> ### Title: Obtain the Horvitz-Thompson direct estimates and standard errors
> ###   using delta method for a single survey.
> ### Aliases: getDirect
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(DemoData)
> ##D years <- c("85-89", "90-94", "95-99", "00-04", "05-09", "10-14")
> ##D mean <- getDirect(births = DemoData[[1]],  years = years, 
> ##D regionVar = "region", timeVar = "time", clusterVar = "~clustid+id", 
> ##D ageVar = "age", weightsVar = "weights", geo.recode = NULL)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("getDirectList")
> ### * getDirectList
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getDirectList
> ### Title: Obtain the Horvitz-Thompson direct estimates and standard errors
> ###   using delta method for multiple surveys.
> ### Aliases: getDirectList
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(DemoData)
> ##D years <- c("85-89", "90-94", "95-99", "00-04", "05-09", "10-14")
> ##D mean <- getDirectList(births = DemoData, years = years, 
> ##D regionVar = "region", timeVar = "time", clusterVar = "~clustid+id", 
> ##D ageVar = "age", weightsVar = "weights", geo.recode = NULL)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("getSmoothed")
> ### * getSmoothed
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getSmoothed
> ### Title: Extract smoothed estimates.
> ### Aliases: getSmoothed
> 
> ### ** Examples
> 
> ## Not run: 
> ##D years <- levels(DemoData[[1]]$time)
> ##D 
> ##D # obtain direct estimates
> ##D data <- getDirectList(births = DemoData, 
> ##D years = years,  
> ##D regionVar = "region", timeVar = "time", 
> ##D clusterVar = "~clustid+id", 
> ##D ageVar = "age", weightsVar = "weights", 
> ##D geo.recode = NULL)
> ##D # obtain direct estimates
> ##D data_multi <- getDirectList(births = DemoData, years = years,
> ##D   regionVar = "region",  timeVar = "time", clusterVar = "~clustid+id",
> ##D   ageVar = "age", weightsVar = "weights", geo.recode = NULL)
> ##D data <- aggregateSurvey(data_multi)
> ##D 
> ##D #  national model
> ##D years.all <- c(years, "15-19")
> ##D fit1 <- smoothDirect(data = data, Amat = NULL, 
> ##D   year_label = years.all, year_range = c(1985, 2019), 
> ##D   rw = 2, is.yearly=FALSE, m = 5)
> ##D out1 <- getSmoothed(fit1)
> ##D plot(out1, is.subnational=FALSE)
> ##D 
> ##D #  subnational model
> ##D fit2 <- smoothDirect(data = data, Amat = mat, 
> ##D   year_label = years.all, year_range = c(1985, 2019), 
> ##D   rw = 2, is.yearly=TRUE, m = 5, type.st = 4)
> ##D out2 <- getSmoothed(fit2)
> ##D plot(out2, is.yearly=TRUE, is.subnational=TRUE)
> ##D 
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("hatchPlot")
> ### * hatchPlot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hatchPlot
> ### Title: Plot maps with uncertainty hatching.
> ### Aliases: hatchPlot
> 
> ### ** Examples
> 
> ## Not run: 
> ##D years <- levels(DemoData[[1]]$time)
> ##D 
> ##D # obtain direct estimates
> ##D data <- getDirectList(births = DemoData, 
> ##D years = years,  
> ##D regionVar = "region", timeVar = "time", 
> ##D clusterVar = "~clustid+id", 
> ##D ageVar = "age", weightsVar = "weights", 
> ##D geo.recode = NULL)
> ##D # obtain direct estimates
> ##D data_multi <- getDirectList(births = DemoData, years = years,
> ##D   regionVar = "region",  timeVar = "time", clusterVar = "~clustid+id",
> ##D   ageVar = "age", weightsVar = "weights", geo.recode = NULL)
> ##D data <- aggregateSurvey(data_multi)
> ##D 
> ##D fit2 <- smoothDirect(data = data, geo = geo, Amat = mat, 
> ##D   year_label = years.all, year_range = c(1985, 2019), 
> ##D   rw = 2, is.yearly=TRUE, m = 5, type.st = 4)
> ##D out2 <- getSmoothed(fit2)
> ##D 
> ##D plot(out2, is.yearly=TRUE, is.subnational=TRUE)
> ##D 
> ##D hatchPlot(data = subset(out2, is.yearly==FALSE), geo = geo,
> ##D variables=c("years"), values = c("median"), 
> ##D by.data = "region", by.geo = "REGNAME", 
> ##D lower = "lower", upper = "upper", is.long=TRUE)
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("logit")
> ### * logit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: logit
> ### Title: Logit transformation
> ### Aliases: logit
> 
> ### ** Examples
> 
> x <- .5
> logit(x)
[1] 0
> 
> 
> 
> 
> cleanEx()
> nameEx("mapPlot")
> ### * mapPlot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mapPlot
> ### Title: Plot region-level variables on a map
> ### Aliases: mapPlot
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(DemoMap)
> ##D # Plotting data in the long format
> ##D dat <- data.frame(region = rep(c("central",  "eastern", "northern", "western"), 3),
> ##D year = rep(c(1980, 1990, 2000), each = 4),
> ##D values = stats::rnorm(12))
> ##D utils::head(dat)
> ##D mapPlot(dat, variables = "year", values = "values",
> ##D by.data = "region", geo = DemoMap$geo,
> ##D by.geo = "NAME_final", is.long = TRUE)
> ##D dat <- data.frame(region = c("central",  "eastern", "northern", "western"),
> ##D Year1 = stats::rnorm(4), Year2 = stats::rnorm(4),
> ##D Year3 = stats::rnorm(4))
> ##D utils::head(dat)
> ##D mapPlot(dat, variables = c("Year1", "Year2", "Year3"),
> ##D  labels = c(1980, 1990, 2000),
> ##D by.data = "region", geo = DemoMap$geo,
> ##D by.geo = "NAME_final", is.long = FALSE)
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("mapPoints")
> ### * mapPoints
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mapPoints
> ### Title: Map GPS points to polygon regions
> ### Aliases: mapPoints
> 
> ### ** Examples
> 
> data(DemoMap) 
> dat <- data.frame(ID = c(1,2,3), lon = c(32.2, 33.7, 33), lat = c(0.1, 0.9, 2.8))
> dat2 <- mapPoints(dat, DemoMap$geo, long = "lon", lat = "lat", names = "REGNAME")
> dat2
  ID  lon lat  REGNAME
1  1 32.2 0.1  central
2  2 33.7 0.9  eastern
3  3 33.0 2.8 northern
>  
> 
> 
> 
> cleanEx()
> nameEx("plot.SUMMERproj")
> ### * plot.SUMMERproj
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.SUMMERproj
> ### Title: Plot projection output.
> ### Aliases: plot.SUMMERproj
> 
> ### ** Examples
> 
> ## Not run: 
> ##D years <- levels(DemoData[[1]]$time)
> ##D 
> ##D # obtain direct estimates
> ##D data <- getDirectList(births = DemoData, 
> ##D years = years,  
> ##D regionVar = "region", timeVar = "time", 
> ##D clusterVar = "~clustid+id", 
> ##D ageVar = "age", weightsVar = "weights", 
> ##D geo.recode = NULL)
> ##D # obtain direct estimates
> ##D data_multi <- getDirectList(births = DemoData, years = years,
> ##D   regionVar = "region",  timeVar = "time", clusterVar = "~clustid+id",
> ##D   ageVar = "age", weightsVar = "weights", geo.recode = NULL)
> ##D data <- aggregateSurvey(data_multi)
> ##D 
> ##D #  national model
> ##D years.all <- c(years, "15-19")
> ##D fit1 <- smoothDirect(data = data, geo = NULL, Amat = NULL, 
> ##D   year_label = years.all, year_range = c(1985, 2019), 
> ##D   rw = 2, is.yearly=FALSE, m = 5)
> ##D out1 <- getSmoothed(fit1)
> ##D plot(out1, is.subnational=FALSE)
> ##D 
> ##D #  subnational model
> ##D fit2 <- smoothDirect(data = data, geo = geo, Amat = mat, 
> ##D   year_label = years.all, year_range = c(1985, 2019), 
> ##D   rw = 2, is.yearly=TRUE, m = 5, type.st = 4)
> ##D out2 <- getSmoothed(fit2)
> ##D plot(out2, is.yearly=TRUE, is.subnational=TRUE)
> ##D 
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("print.SUMMERmodel")
> ### * print.SUMMERmodel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.SUMMERmodel
> ### Title: Print method for the smoothing models.
> ### Aliases: print.SUMMERmodel
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   library(SUMMER)
> ##D   library(dplyr)
> ##D   data(DemoData)
> ##D 
> ##D   # Smooth Direct Model
> ##D   years <- levels(DemoData[[1]]$time)
> ##D   # obtain direct estimates
> ##D   data_multi <- getDirectList(births = DemoData, years = years,
> ##D   regionVar = "region",  timeVar = "time", clusterVar = "~clustid+id",
> ##D   ageVar = "age", weightsVar = "weights", geo.recode = NULL)
> ##D   data <- aggregateSurvey(data_multi)
> ##D   
> ##D   years.all <- c(years, "15-19")
> ##D   fit <- smoothDirect(data = data, Amat = NULL, 
> ##D   year_label = years.all, year_range = c(1985, 2019), 
> ##D   time.model = 'rw2', is.yearly=FALSE, m = 5)
> ##D   fit
> ##D 
> ##D   # Cluster-level Model
> ##D   counts.all <- NULL
> ##D   for(i in 1:length(DemoData)){
> ##D   counts <- getCounts(DemoData[[i]][, c("clustid", "time", "age", "died",
> ##D                                        "region", "strata")],
> ##D            variables = 'died', by = c("age", "clustid", "region", 
> ##D                                         "time", "strata"))
> ##D   counts <- counts %>% mutate(cluster = clustid, years = time, Y=died)
> ##D   counts$strata <- gsub(".*\\.","",counts$strata)
> ##D   counts$survey <- names(DemoData)[i] 
> ##D   counts.all <- rbind(counts.all, counts)
> ##D   }
> ##D   
> ##D   # fit cluster-level model on the periods
> ##D   periods <- levels(DemoData[[1]]$time)
> ##D   fit <- smoothCluster(data = counts.all, 
> ##D      Amat = DemoMap$Amat, 
> ##D      time.model = "rw2", 
> ##D      st.time.model = "rw1",
> ##D      strata.time.effect =  TRUE, 
> ##D      survey.effect = TRUE,
> ##D      family = "betabinomial",
> ##D      year_label = c(periods, "15-19"))
> ##D   fit
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("print.SUMMERmodel.svy")
> ### * print.SUMMERmodel.svy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.SUMMERmodel.svy
> ### Title: Print method for the smoothing models from 'smoothSurvey'.
> ### Aliases: print.SUMMERmodel.svy
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(DemoData2)
> ##D data(DemoMap2)
> ##D fit0 <- smoothSurvey(data=DemoData2,  
> ##D Amat=DemoMap2$Amat, responseType="binary", 
> ##D responseVar="tobacco.use", strataVar="strata", 
> ##D weightVar="weights", regionVar="region", 
> ##D clusterVar = "~clustid+id", CI = 0.95)
> ##D fit0
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("print.SUMMERprojlist")
> ### * print.SUMMERprojlist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.SUMMERprojlist
> ### Title: Print method for the combined projection output.
> ### Aliases: print.SUMMERprojlist
> 
> ### ** Examples
> 
> ## Not run: 
> ##D  library(SUMMER)
> ##D  library(dplyr)
> ##D  data(DemoData)
> ##D  # Create dataset of counts
> ##D  counts.all <- NULL
> ##D  for(i in 1:length(DemoData)){
> ##D  counts <- getCounts(DemoData[[i]][, c("clustid", "time", "age", "died",
> ##D                                       "region", "strata")],
> ##D           variables = 'died', by = c("age", "clustid", "region", 
> ##D                                        "time", "strata"))
> ##D  counts <- counts %>% mutate(cluster = clustid, years = time, Y=died)
> ##D  counts$strata <- gsub(".*\\.","",counts$strata)
> ##D  counts$survey <- names(DemoData)[i] 
> ##D  counts.all <- rbind(counts.all, counts)
> ##D  }
> ##D  
> ##D  # fit cluster-level model on the periods
> ##D  periods <- levels(DemoData[[1]]$time)
> ##D  fit <- smoothCluster(data = counts.all, 
> ##D     Amat = DemoMap$Amat, 
> ##D     time.model = "rw2", 
> ##D     st.time.model = "rw1",
> ##D     strata.time.effect =  TRUE, 
> ##D     survey.effect = TRUE,
> ##D     family = "betabinomial",
> ##D     year_label = c(periods, "15-19"))
> ##D  summary(fit)
> ##D  est <- getSmoothed(fit, nsim = 1000)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ridgePlot")
> ### * ridgePlot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ridgePlot
> ### Title: Calculate and plot posterior densities of the projected
> ###   estimates
> ### Aliases: ridgePlot getSmoothedDensity
> 
> ### ** Examples
> 
> ## Not run: 
> ##D years <- levels(DemoData[[1]]$time)
> ##D 
> ##D data <- getDirectList(births = DemoData, 
> ##D years = years,  
> ##D regionVar = "region", timeVar = "time", 
> ##D clusterVar = "~clustid+id", 
> ##D ageVar = "age", weightsVar = "weights", 
> ##D geo.recode = NULL)
> ##D # obtain direct estimates
> ##D data_multi <- getDirectList(births = DemoData, years = years,
> ##D   regionVar = "region",  timeVar = "time", clusterVar = "~clustid+id",
> ##D   ageVar = "age", weightsVar = "weights", geo.recode = NULL)
> ##D data <- aggregateSurvey(data_multi)
> ##D 
> ##D #  national model
> ##D years.all <- c(years, "15-19")
> ##D fit1 <- smoothDirect(data = data, geo = NULL, Amat = NULL, 
> ##D   year_label = years.all, year_range = c(1985, 2019), 
> ##D   rw = 2, m = 5)
> ##D ## Plot marginal posterior densities over time
> ##D ridgePlot(fit1, year_plot = years.all, 
> ##D           ncol = 4, by.year = FALSE)
> ##D 
> ##D #  subnational model
> ##D fit2 <- smoothDirect(data = data, geo = DemoMap$geo, Amat = DemoMap$Amat, 
> ##D   year_label = years.all, year_range = c(1985, 2019), 
> ##D   rw = 2, m = 5, type.st = 1)
> ##D 
> ##D # Plot marginal posterior densities over time (regions are ordered alphabetically)
> ##D ridgePlot(fit2, year_plot = years.all, ncol = 4)
> ##D 
> ##D # Re-order the regions and save the density to avoid re-compute later
> ##D density <- ridgePlot(fit2, year_plot = years.all,
> ##D  ncol = 4, per1000 = TRUE, order = -1, save.density = TRUE)
> ##D density$g
> ##D 
> ##D # Show each region (instead of each year) in a panel 
> ##D ## Instead of recalculate the posteriors, we can use previously calculated densities as input 
> ##D ridgePlot(results = density, year_plot = years.all, 
> ##D ncol = 4, by.year=FALSE, per1000 = TRUE)
> ##D 
> ##D # Show more years
> ##D ridgePlot(results = density, year_plot = c(1990:2019), 
> ##D ncol = 4, by.year=FALSE, per1000 = TRUE)
> ##D 
> ##D 
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("rst")
> ### * rst
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rst
> ### Title: Simulate spatial and temporal random effects
> ### Aliases: rst
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(DemoMap)
> ##D ## Spatial random effects 
> ##D out <- rst(n=10000, type = "s", Amat = DemoMap$Amat)
> ##D # To verify the mean under the conditional specification
> ##D mean(out[,1] - apply(out[,c(2,3,4)], 1, mean))  
> ##D mean(out[,2] - apply(out[,c(1,3)], 1, mean)) 
> ##D mean(out[,3] - apply(out[,c(1,2,4)], 1, mean))  
> ##D mean(out[,4] - apply(out[,c(1,3)], 1, mean)) 
> ##D 
> ##D ## Temporal random effects (RW1)
> ##D out <- rst(n=1, type = "t", type.t = "RW1", n.t = 200, scale.model = FALSE)
> ##D par(mfrow = c(1,2))
> ##D plot(1:dim(out)[2], out, col = 1, type = "l", xlab = "Time", ylab = "Random effects")
> ##D # verify the first order difference is normally distributed
> ##D first_diff <- diff(as.numeric(out[1,]))
> ##D qqnorm(first_diff )	
> ##D abline(c(0,1))
> ##D 
> ##D ## Temporal random effects (RW2)
> ##D out <- rst(n=1, type = "t", type.t = "RW2", n.t = 200, scale.model = FALSE)
> ##D par(mfrow = c(1,2))
> ##D plot(1:dim(out)[2], out, col = 1, type = "l", xlab = "Time", ylab = "Random effects")
> ##D # verify the second order difference is normally distributed
> ##D first_diff <- diff(as.numeric(out[1,]))
> ##D second_diff <- diff(first_diff)
> ##D qqnorm(second_diff)	
> ##D abline(c(0,1))
> ##D 
> ##D ## Spatial-temporal random effects
> ##D out <- rst(n=1, type = "st", type.t = "RW2", Amat = DemoMap$Amat, n.t = 50)
> ##D dimnames(out)
> ##D par(mfrow = c(1,1))
> ##D plot(1:dim(out)[3], out[1,1,], col = 1,
> ##D  type = "l", ylim = range(out), xlab = "Time", ylab = "Random effects")
> ##D for(i in 2:4) lines(1:dim(out)[3], out[1,i,], col = i)
> ##D legend("bottomright", colnames(DemoMap$Amat), col = c(1:4), lty = rep(1,4))
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("simhyper")
> ### * simhyper
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simhyper
> ### Title: Simulate hyperpriors from an GMRF
> ### Aliases: simhyper
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(DemoMap)
> ##D mat <- DemoMap$Amat
> ##D priors <- simhyper(R = 2, nsamp = 1e+05, nsamp.check = 5000, Amat = mat)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("smoothArea")
> ### * smoothArea
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: smoothArea
> ### Title: Smooth via area level model
> ### Aliases: smoothArea
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(survey)
> ##D data(DemoData2)
> ##D data(DemoMap2)
> ##D des0 <- svydesign(ids = ~clustid+id, strata = ~strata,
> ##D                   weights = ~weights, data = DemoData2, nest = T)
> ##D Xmat <- aggregate(age~region, data = DemoData2, FUN = mean)
> ##D 
> ##D EXAMPLE 1: Continuous response model
> ##D cts.res <- smoothArea(tobacco.use ~ 1, domain = ~region,
> ##D                       Amat = DemoMap2$Amat, design = des0,
> ##D                       pc.u = 1,
> ##D                       pc.alpha = 0.01,
> ##D                       pc.u.phi = 0.5,
> ##D                       pc.alpha.phi = 2/3)
> ##D                       
> ##D EXAMPLE 2: Including area level covariates
> ##D cts.cov.res <- smoothArea(tobacco.use ~ age, domain = ~region,
> ##D                           Amat = DemoMap2$Amat, design = des0,
> ##D                           X.area = Xmat,
> ##D                           pc.u = 1,
> ##D                           pc.alpha = 0.01,
> ##D                           pc.u.phi = 0.5,
> ##D                           pc.alpha.phi = 2/3)
> ##D                           
> ##D EXAMPLE 3: Binary response model
> ##D bin.res <- smoothArea(tobacco.use ~ 1, domain = ~region,
> ##D                       responseType = "binary",
> ##D                       Amat = DemoMap2$Amat, design = des0,
> ##D                       pc.u = 1,
> ##D                       pc.alpha = 0.01,
> ##D                       pc.u.phi = 0.5,
> ##D                       pc.alpha.phi = 2/3)
> ##D                       
> ##D EXAMPLE 4: Including area level covariates in binary response model
> ##D bin.cov.res <- smoothArea(tobacco.use ~ age, domain = ~region,
> ##D                           responseType = "binary",
> ##D                           Amat = DemoMap2$Amat, design = des0,
> ##D                           X.area = Xmat,
> ##D                           pc.u = 1,
> ##D                           pc.alpha = 0.01,
> ##D                           pc.u.phi = 0.5,
> ##D                           pc.alpha.phi = 2/3)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("smoothCluster")
> ### * smoothCluster
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: smoothCluster
> ### Title: Cluster-level space-time smoothing models for mortality rates
> ### Aliases: smoothCluster fitINLA2
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(dplyr)
> ##D data(DemoData)
> ##D # Create dataset of counts
> ##D counts.all <- NULL
> ##D for(i in 1:length(DemoData)){
> ##D   counts <- getCounts(DemoData[[i]][, c("clustid", "time", "age", "died",
> ##D                                         "region", "strata")],
> ##D             variables = 'died', by = c("age", "clustid", "region", 
> ##D                                          "time", "strata"))
> ##D   counts <- counts %>% mutate(cluster = clustid, years = time, Y=died)
> ##D   counts$strata <- gsub(".*\\.","",counts$strata)
> ##D   counts$survey <- names(DemoData)[i] 
> ##D   counts.all <- rbind(counts.all, counts)
> ##D }
> ##D 
> ##D # fit cluster-level model on the periods
> ##D periods <- levels(DemoData[[1]]$time)
> ##D fit <- smoothCluster(data = counts.all, 
> ##D      Amat = DemoMap$Amat, 
> ##D      time.model = "rw2", 
> ##D      st.time.model = "rw1",
> ##D      strata.time.effect =  TRUE, 
> ##D      survey.effect = TRUE,
> ##D      family = "betabinomial",
> ##D      year_label = c(periods, "15-19"))
> ##D summary(fit)
> ##D est <- getSmoothed(fit, nsim = 1000)
> ##D plot(est$stratified, plot.CI=TRUE) + ggplot2::facet_wrap(~strata) 
> ##D 
> ##D # fit cluster-level space-time model with covariate
> ##D # notice without projected covariates, we use periods up to 10-14 only
> ##D # construct a random covariate matrix for illustration
> ##D periods <- levels(DemoData[[1]]$time)
> ##D X <- expand.grid(years = periods, 
> ##D        region = unique(counts.all$region))
> ##D X$X1 <- rnorm(dim(X)[1])
> ##D X$X2 <- rnorm(dim(X)[1])
> ##D fit.covariate <- smoothCluster(data = counts.all, 
> ##D    X = X,
> ##D      Amat = DemoMap$Amat, 
> ##D      time.model = "rw2", 
> ##D      st.time.model = "rw1",
> ##D      strata.time.effect =  TRUE, 
> ##D      survey.effect = TRUE,
> ##D      family = "betabinomial",
> ##D      year_label = c(periods))
> ##D est <- getSmoothed(fit.covariate, nsim = 1000)
> ##D 
> ##D # fit cluster-level model for one time point only
> ##D # i.e., space-only model
> ##D fit.sp <- smoothCluster(data = subset(counts.all, time == "10-14"), 
> ##D      Amat = DemoMap$Amat, 
> ##D      time.model = NULL, 
> ##D      survey.effect = TRUE,
> ##D      family = "betabinomial")
> ##D summary(fit.sp)
> ##D est <- getSmoothed(fit.sp, nsim = 1000)
> ##D plot(est$stratified, plot.CI = TRUE) + ggplot2::facet_wrap(~strata) 
> ##D 
> ##D # fit cluster-level model for one time point and covariate
> ##D # construct a random covariate matrix for illustration
> ##D X <- data.frame(region = unique(counts.all$region),
> ##D       X1 = c(1, 2, 2, 1), 
> ##D       X2 = c(1, 1, 1, 2))
> ##D fit.sp.covariate <- smoothCluster(data = subset(counts.all, time == "10-14"), 
> ##D      X = X, 
> ##D      Amat = DemoMap$Amat, 
> ##D      time.model = NULL, 
> ##D      survey.effect = TRUE,
> ##D      family = "betabinomial")
> ##D summary(fit.sp.covariate)
> ##D est <- getSmoothed(fit.sp.covariate, nsim = 1000)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("smoothDirect")
> ### * smoothDirect
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: smoothDirect
> ### Title: Smoothed direct estimates for mortality rates
> ### Aliases: smoothDirect fitINLA
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   years <- levels(DemoData[[1]]$time)
> ##D   # obtain direct estimates
> ##D   data_multi <- getDirectList(births = DemoData, years = years,
> ##D   regionVar = "region",  timeVar = "time", clusterVar = "~clustid+id",
> ##D   ageVar = "age", weightsVar = "weights", geo.recode = NULL)
> ##D   data <- aggregateSurvey(data_multi)
> ##D   
> ##D   #  national model
> ##D   years.all <- c(years, "15-19")
> ##D   fit1 <- smoothDirect(data = data, Amat = NULL, 
> ##D   year_label = years.all, year_range = c(1985, 2019), 
> ##D   time.model = 'rw2', is.yearly=FALSE, m = 5, control.compute = list(config =TRUE))
> ##D   out1 <- getSmoothed(fit1)
> ##D   plot(out1)
> ##D   
> ##D   #  subnational model
> ##D   fit2 <- smoothDirect(data = data, Amat = DemoMap$Amat, 
> ##D   year_label = years.all, year_range = c(1985, 2019), 
> ##D   time.model = 'rw2',is.yearly=TRUE, m = 5, type.st = 4)
> ##D   out2 <- getSmoothed(fit2)
> ##D   plot(out2)
> ##D   
> ##D   #  subnational space-only model for one period
> ##D   fit3 <- smoothDirect(data = subset(data, years == "10-14"), 
> ##D            time.model = NULL, Amat = DemoMap$Amat)
> ##D   source('projINLA.R')
> ##D   out3 <- getSmoothed(fit3)
> ##D   plot(out3, plot.CI = TRUE)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("smoothSurvey")
> ### * smoothSurvey
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: smoothSurvey
> ### Title: Fit space-time smoothing models for a generic outcome from
> ###   complex surveys.
> ### Aliases: smoothSurvey fitGeneric
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ##
> ##D ## 1. Area-level model with binary response
> ##D ##
> ##D 
> ##D data(DemoData2)
> ##D data(DemoMap2)
> ##D fit0 <- smoothSurvey(data=DemoData2,  
> ##D Amat=DemoMap2$Amat, responseType="binary", 
> ##D responseVar="tobacco.use", strataVar="strata", 
> ##D weightVar="weights", regionVar="region", 
> ##D clusterVar = "~clustid+id", CI = 0.95)
> ##D summary(fit0)
> ##D 
> ##D # posterior draws can be returned with save.draws = TRUE
> ##D fit0.draws <- smoothSurvey(data=DemoData2,  
> ##D Amat=DemoMap2$Amat, responseType="binary", 
> ##D responseVar="tobacco.use", strataVar="strata", 
> ##D weightVar="weights", regionVar="region", 
> ##D clusterVar = "~clustid+id", CI = 0.95, save.draws = TRUE)
> ##D # notice the posterior draws are on the latent scale
> ##D head(fit0.draws$draws.est[, 1:10]) 
> ##D 
> ##D # Example with region-level covariates
> ##D  Xmat <- aggregate(age~region, data = DemoData2, FUN = mean)
> ##D  fit1 <- smoothSurvey(data=DemoData2,  
> ##D   Amat=DemoMap2$Amat, responseType="binary", 
> ##D   X = Xmat,
> ##D   responseVar="tobacco.use", strataVar="strata", 
> ##D   weightVar="weights", regionVar="region", 
> ##D   clusterVar = "~clustid+id", CI = 0.95)
> ##D 
> ##D # Example with using only direct estimates as input instead of the full data
> ##D direct <- fit0$HT[, c("region", "HT.est", "HT.var")]
> ##D fit2 <- smoothSurvey(data=NULL, direct.est = direct, 
> ##D                     Amat=DemoMap2$Amat, regionVar="region",
> ##D                     responseVar="HT.est", direct.est.var = "HT.var", 
> ##D                     responseType = "binary")
> ##D # Check it is the same as fit0
> ##D plot(fit2$smooth$mean, fit0$smooth$mean)
> ##D 
> ##D # Example with using only direct estimates as input, 
> ##D #   and after transformation into a Gaussian smoothing model
> ##D # Notice: the output are on the same scale as the input 
> ##D #   and in this case, the logit estimates.    
> ##D direct.logit <- fit0$HT[, c("region", "HT.logit.est", "HT.logit.var")]
> ##D fit3 <- smoothSurvey(data=NULL, direct.est = direct.logit, 
> ##D                Amat=DemoMap2$Amat, regionVar="region",
> ##D                responseVar="HT.logit.est", direct.est.var = "HT.logit.var",
> ##D                responseType = "gaussian")
> ##D # Check it is the same as fit0
> ##D plot(fit3$smooth$mean, fit0$smooth$logit.mean)
> ##D 
> ##D # Example with non-spatial smoothing using IID random effects
> ##D fit4 <- smoothSurvey(data=DemoData2, responseType="binary", 
> ##D        responseVar="tobacco.use", strataVar="strata", 
> ##D        weightVar="weights", regionVar="region", 
> ##D        clusterVar = "~clustid+id", CI = 0.95)
> ##D 
> ##D # Using the formula argument, further customizations can be added to the 
> ##D #  model fitted. For example, we can fit the Fay-Harriot model with 
> ##D #  IID effect instead of the BYM2 random effect as follows.
> ##D #  The "region.struct" and "hyperpc1" are picked to match internal object 
> ##D #  names. Other object names can be inspected from the source of smoothSurvey.
> ##D fit5 <- smoothSurvey(data=DemoData2,  
> ##D        Amat=DemoMap2$Amat, responseType="binary", 
> ##D        formula = "f(region.struct, model = 'iid', hyper = hyperpc1)",
> ##D        pc.u = 1, pc.alpha = 0.01,
> ##D        responseVar="tobacco.use", strataVar="strata", 
> ##D        weightVar="weights", regionVar="region", 
> ##D        clusterVar = "~clustid+id", CI = 0.95)
> ##D # Check it is the same as fit4, notice the region order may be different
> ##D regions <- fit5$smooth$region
> ##D plot(fit4$smooth[match(regions, fit4$smooth$region),]$logit.mean, fit5$smooth$logit.mean)
> ##D 
> ##D ##
> ##D ## 2. Unit-level model with binary response  
> ##D ##
> ##D 
> ##D # For unit-level models, we need to create stratification variable within regions
> ##D data <- DemoData2
> ##D data$urbanicity <- "rural"
> ##D data$urbanicity[grep("urban", data$strata)] <- "urban"
> ##D 
> ##D # Beta-binomial likelihood is used in this model
> ##D fit6 <- smoothSurvey(data=data, 
> ##D   Amat=DemoMap2$Amat, responseType="binary", 
> ##D   X = Xmat, is.unit.level = TRUE,
> ##D   responseVar="tobacco.use", strataVar.within = "urbanicity", 
> ##D   regionVar="region", clusterVar = "clustid", CI = 0.95)
> ##D 
> ##D # We may use aggregated PSU-level counts as input as well
> ##D #    in the case of modeling a binary outcome 
> ##D data.agg <- aggregate(tobacco.use~region + urbanicity + clustid, 
> ##D                       data = data, FUN = sum)
> ##D data.agg.total <- aggregate(tobacco.use~region + urbanicity + clustid, 
> ##D                       data = data, FUN = length)
> ##D colnames(data.agg.total)[4] <- "total"
> ##D data.agg <- merge(data.agg, data.agg.total)
> ##D head(data.agg)
> ##D 
> ##D fit7 <- smoothSurvey(data=data.agg, 
> ##D   Amat=DemoMap2$Amat, responseType="binary", 
> ##D   X = Xmat, is.unit.level = TRUE, is.agg = TRUE,
> ##D   responseVar = "tobacco.use", strataVar.within = "urbanicity", 
> ##D   totalVar = "total", regionVar="region", clusterVar = "clustid", CI = 0.95)
> ##D 
> ##D # Check it is the same as fit6
> ##D plot(fit6$smooth$mean, fit7$smooth$mean)  
> ##D 
> ##D ##
> ##D ## 3. Area-level model with continuous response
> ##D ##
> ##D 
> ##D # The smoothing model is the same as area-level model with binary response
> ##D #  the continuous direct estimates are smoothed instead of 
> ##D #  their logit-transformed versions for binary response.
> ##D fit8 <- smoothSurvey(data=DemoData2, Amat=DemoMap2$Amat, 
> ##D        responseType="gaussian", responseVar="age", strataVar="strata", 
> ##D        weightVar="weights", regionVar="region", 
> ##D        pc.u.phi = 0.5, pc.alpha.phi = 0.5,
> ##D        clusterVar = "~clustid+id", CI = 0.95)
> ##D 
> ##D ##
> ##D ## 4. Unit-level model with continuous response  
> ##D ##    (or nested error models)
> ##D 
> ##D # The unit-level model assumes for each of the i-th unit,
> ##D #    Y_{i} ~ intercept + region_effect + IID_i
> ##D #    where IID_i is the error term specific to i-th unit
> ##D 
> ##D # When more than one level of cluster sampling is carried out, 
> ##D #   they are ignored here. Only the input unit is considered.
> ##D #   So here we do not need to specify clusterVar any more. 
> ##D fit9 <- smoothSurvey(data= data, 
> ##D   Amat=DemoMap2$Amat, responseType="gaussian", 
> ##D   is.unit.level = TRUE, responseVar="age", strataVar.within = NULL,
> ##D   regionVar="region", clusterVar = NULL, CI = 0.95)
> ##D 
> ##D # To compare, we may also model PSU-level responses. As an illustration, 
> ##D data.median <- aggregate(age~region + urbanicity + clustid, 
> ##D                       data = data, FUN = median)
> ##D 
> ##D fit10 <- smoothSurvey(data= data.median, 
> ##D   Amat=DemoMap2$Amat, responseType="gaussian", 
> ##D   is.unit.level = TRUE, responseVar="age", strataVar.within = NULL,
> ##D   regionVar="region", clusterVar = "clustid", CI = 0.95)
> ##D 
> ##D 
> ##D # To further incorporate within-area stratification
> ##D 
> ##D fit11 <- smoothSurvey(data = data, 
> ##D   Amat = DemoMap2$Amat, responseType = "gaussian", 
> ##D   is.unit.level = TRUE, responseVar="age", strataVar.within = "urbanicity",
> ##D   regionVar = "region", clusterVar = NULL, CI = 0.95)  
> ##D 
> ##D # Notice the usual output is now stratified within each region
> ##D # The aggregated estimates require strata proportions for each region
> ##D # For illustration, we set strata population proportions below
> ##D prop <- data.frame(region = unique(data$region), 
> ##D                             urban = 0.3, 
> ##D                             rural = 0.7)
> ##D fit12 <- smoothSurvey(data=data, 
> ##D   Amat=DemoMap2$Amat, responseType="gaussian", 
> ##D   is.unit.level = TRUE, responseVar="age", strataVar.within = "urbanicity",
> ##D   regionVar="region", clusterVar = NULL, CI = 0.95,
> ##D   weight.strata = prop)  
> ##D 
> ##D # aggregated outcome
> ##D head(fit12$smooth.overall)
> ##D 
> ##D # Compare aggregated outcome with direct aggregating posterior means. 
> ##D # There could be small differences if only 1000 posterior draws are taken.
> ##D est.urb <- subset(fit11$smooth, strata == "urban")
> ##D est.rural <- subset(fit11$smooth, strata == "rural")
> ##D est.mean.post <- est.urb$mean * 0.3 + est.rural$mean * 0.7
> ##D plot(fit12$smooth.overall$mean, est.mean.post)
> ##D 
> ##D 
> ##D ##
> ##D ## 6. Unit-level model with continuous response and unit-level covariate 
> ##D ## 
> ##D 
> ##D # For area-level prediction, area-level covariate mean needs to be  
> ##D #   specified in X argument. And unit-level covariate names are specified
> ##D #   in X.unit argument.
> ##D 
> ##D set.seed(1)
> ##D sim <- data.frame(region = rep(c(1, 2, 3, 4), 1000),
> ##D                    X1 = rnorm(4000), X2 = rnorm(4000))
> ##D Xmean <- aggregate(.~region, data = sim, FUN = sum)
> ##D sim$Y <- rnorm(4000, mean = sim$X1 + 0.3 * sim$X2 + sim$region)
> ##D samp <- sim[sample(1:4000, 20), ]
> ##D fit.sim <- smoothSurvey(data=samp , 
> ##D                   X.unit = c("X1", "X2"),
> ##D                   X = Xmean, Amat=NULL, responseType="gaussian", 
> ##D                   is.unit.level = TRUE, responseVar="Y", regionVar = "region",  
> ##D                   pc.u = 1, pc.alpha = 0.01, CI = 0.95) 
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("smoothUnit")
> ### * smoothUnit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: smoothUnit
> ### Title: Smooth via unit level model
> ### Aliases: smoothUnit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(survey)
> ##D data(DemoData2)
> ##D data(DemoMap2)
> ##D des0 <- svydesign(ids = ~clustid+id, strata = ~strata,
> ##D                  weights = ~weights, data = DemoData2, nest = T)
> ##D                  
> ##D EXAMPLE 1: Continuous response model
> ##D cts.res <- smoothUnit(formula = tobacco.use ~ 1,
> ##D                       domain = ~region,
> ##D                       design = des0, X.pop = DemoData2)
> ##D                       
> ##D EXAMPLE 2: Binary response model
> ##D bin.res <- smoothUnit(formula = tobacco.use ~ 1,
> ##D                       family = "binomial",
> ##D                       domain = ~region,
> ##D                       design = des0, X.pop = DemoData2)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("summary.SUMMERmodel")
> ### * summary.SUMMERmodel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.SUMMERmodel
> ### Title: Summary method for the smoothing models.
> ### Aliases: summary.SUMMERmodel
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   library(SUMMER)
> ##D   library(dplyr)
> ##D   data(DemoData)
> ##D 
> ##D   # Smooth Direct Model
> ##D   years <- levels(DemoData[[1]]$time)
> ##D   # obtain direct estimates
> ##D   data_multi <- getDirectList(births = DemoData, years = years,
> ##D   regionVar = "region",  timeVar = "time", clusterVar = "~clustid+id",
> ##D   ageVar = "age", weightsVar = "weights", geo.recode = NULL)
> ##D   data <- aggregateSurvey(data_multi)
> ##D   
> ##D   years.all <- c(years, "15-19")
> ##D   fit <- smoothDirect(data = data, Amat = NULL, 
> ##D   year_label = years.all, year_range = c(1985, 2019), 
> ##D   time.model = 'rw2', is.yearly=FALSE, m = 5)
> ##D   summary(fit)
> ##D 
> ##D   # Cluster-level Model
> ##D   counts.all <- NULL
> ##D   for(i in 1:length(DemoData)){
> ##D   counts <- getCounts(DemoData[[i]][, c("clustid", "time", "age", "died",
> ##D                                        "region", "strata")],
> ##D            variables = 'died', by = c("age", "clustid", "region", 
> ##D                                         "time", "strata"))
> ##D   counts <- counts %>% mutate(cluster = clustid, years = time, Y=died)
> ##D   counts$strata <- gsub(".*\\.","",counts$strata)
> ##D   counts$survey <- names(DemoData)[i] 
> ##D   counts.all <- rbind(counts.all, counts)
> ##D   }
> ##D   
> ##D   # fit cluster-level model on the periods
> ##D   periods <- levels(DemoData[[1]]$time)
> ##D   fit <- smoothCluster(data = counts.all, 
> ##D      Amat = DemoMap$Amat, 
> ##D      time.model = "rw2", 
> ##D      st.time.model = "rw1",
> ##D      strata.time.effect =  TRUE, 
> ##D      survey.effect = TRUE,
> ##D      family = "betabinomial",
> ##D      year_label = c(periods, "15-19"))
> ##D   summary(fit) 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("summary.SUMMERmodel.svy")
> ### * summary.SUMMERmodel.svy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.SUMMERmodel.svy
> ### Title: Summary method for the smoothing model and output from
> ###   'smoothSurvey'.
> ### Aliases: summary.SUMMERmodel.svy
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(DemoData2)
> ##D data(DemoMap2)
> ##D fit0 <- smoothSurvey(data=DemoData2,  
> ##D Amat=DemoMap2$Amat, responseType="binary", 
> ##D responseVar="tobacco.use", strataVar="strata", 
> ##D weightVar="weights", regionVar="region", 
> ##D clusterVar = "~clustid+id", CI = 0.95)
> ##D summary(fit0)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("tcpPlot")
> ### * tcpPlot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tcpPlot
> ### Title: Discrete-color maps based on the True Classification
> ###   Probabilities
> ### Aliases: tcpPlot
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(dplyr)
> ##D data(DemoData)
> ##D # Create dataset of counts, unstratified
> ##D counts.all <- NULL
> ##D for(i in 1:length(DemoData)){
> ##D   counts <- getCounts(DemoData[[i]][, c("clustid", "time", "age", "died",
> ##D                                         "region")],
> ##D             variables = 'died', by = c("age", "clustid", "region", 
> ##D                                          "time"))
> ##D   counts <- counts %>% mutate(cluster = clustid, years = time, Y=died)
> ##D   counts$strata <- NA
> ##D   counts$survey <- names(DemoData)[i] 
> ##D   counts.all <- rbind(counts.all, counts)
> ##D }
> ##D 
> ##D # fit cluster-level model on the periods
> ##D periods <- levels(DemoData[[1]]$time)
> ##D fit <- smoothCluster(data = counts.all, 
> ##D       Amat = DemoMap$Amat, 
> ##D       time.model = "rw2", 
> ##D       st.time.model = "rw1",
> ##D       strata.time.effect =  TRUE, 
> ##D       survey.effect = TRUE,
> ##D       family = "betabinomial",
> ##D       year_label = c(periods, "15-19"))
> ##D est <- getSmoothed(fit, nsim = 1000, save.draws=TRUE)
> ##D 
> ##D tcp <- tcpPlot(est, DemoMap$geo, by.geo = "REGNAME", interval = 3, year_plot = periods) 
> ##D tcp$g
> ## End(Not run)
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  1.102 0.063 1.177 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
