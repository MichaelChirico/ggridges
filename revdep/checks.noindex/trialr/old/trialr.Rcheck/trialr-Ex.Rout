
R version 4.3.1 (2023-06-16) -- "Beagle Scouts"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin20 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "trialr"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('trialr')
Loading required package: Rcpp
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("binary_prob_success")
> ### * binary_prob_success
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: binary_prob_success
> ### Title: Calculate the binary probability of success.
> ### Aliases: binary_prob_success binary_prob_success.augbin_2t_1a_fit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- stan_augbin_demo()
> ##D binary_prob_success(fit, y2_upper = log(0.7))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("careful_escalation")
> ### * careful_escalation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: careful_escalation
> ### Title: Dose selection function that practices careful escalation.
> ### Aliases: careful_escalation
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # CRM example
> ##D fit <- stan_crm('1N 2N 3T', skeleton = c(0.1, 0.2, 0.35, 0.6),
> ##D                 target = 0.2, model = 'empiric', beta_sd = 1,
> ##D                 seed = 123)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("closest_to_target")
> ### * closest_to_target
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: closest_to_target
> ### Title: Get index of element in vector with value closest to a target
> ### Aliases: closest_to_target
> 
> ### ** Examples
> 
> closest_to_target(c(0.1, 0.2, 0.3), 0.05)  # 1
[1] 1
> closest_to_target(c(0.1, 0.2, 0.3), 0.22)  # 2
[1] 2
> closest_to_target(c(0.1, 0.2, 0.3), -0.05) # 1
[1] 1
> closest_to_target(c(0.1, 0.2, 0.3), 8) # 3
[1] 3
> 
> 
> 
> cleanEx()
> nameEx("crm_codified_dose_logistic")
> ### * crm_codified_dose_logistic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: crm_codified_dose_logistic
> ### Title: Calculate codified CRM doses.
> ### Aliases: crm_codified_dose_logistic
> 
> ### ** Examples
> 
> skeleton <- c(0.05, 0.1, 0.2, 0.5)
> crm_codified_dose_logistic(skeleton, 1, 0)
[1] -Inf -Inf -Inf -Inf
> crm_codified_dose_logistic(skeleton, 3, 0.5)
[1] -11.888878 -10.394449  -8.772589  -6.000000
> 
> 
> 
> cleanEx()
> nameEx("crm_dtps")
> ### * crm_dtps
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: crm_dtps
> ### Title: Calculate dose-transition pathways for a CRM study
> ### Aliases: crm_dtps
> 
> ### ** Examples
> 
> ## Not run: 
> ##D target <- 0.25
> ##D skeleton <- c(0.05, 0.15, 0.25, 0.4, 0.6)
> ##D 
> ##D # Run DTPs for the first two cohorts of two for new a trial:
> ##D paths <- crm_dtps(skeleton = skeleton, target = target, model = 'empiric',
> ##D                   cohort_sizes = c(2, 2), next_dose = 3, beta_sd = 1)
> ##D length(paths)  # 13
> ##D 
> ##D library(tibble)
> ##D df <- as_tibble(paths)
> ##D df
> ##D 
> ##D 
> ##D # Run DTPs for the next cohort of three in a trial that has already treated
> ##D # six patients, seeing some toxicity at dose-level 3:
> ##D paths2 <- crm_dtps(skeleton = skeleton, target = target, model = 'empiric',
> ##D                    cohort_sizes = c(3), previous_outcomes = '2NNN 3TTN',
> ##D                    beta_sd = 1)
> ##D length(paths2)  # 5
> ##D as_tibble(paths2)
> ##D # We see that de-escalation to dose-level 2 should occur now, and that any
> ##D # further toxicity will result in advice for further de-escalation to
> ##D # dose-level 1.
> ##D 
> ##D 
> ##D # An example with a custom dose selection function
> ##D paths3 <- crm_dtps(skeleton = skeleton, target = target, model = 'empiric',
> ##D                    cohort_sizes = c(3, 3), previous_outcomes = '2NN 3TN',
> ##D                    next_dose = 2, beta_sd = 1,
> ##D                    user_dose_func = function(x) {
> ##D                      careful_escalation(x, tox_threshold = target + 0.1,
> ##D                                         certainty_threshold = 0.7)
> ##D                    }, seed = 123, refresh = 0)
> ##D spread_paths(as_tibble(paths3) %>% select(-fit, -parent_fit, -dose_index))
> ##D # Stopping is recommended when the dose selection function returns NA.
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("crm_path_analysis")
> ### * crm_path_analysis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: crm_path_analysis
> ### Title: Fit a CRM model to the incrementally observed outcomes on a
> ###   trial pathway.
> ### Aliases: crm_path_analysis
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # CRM example
> ##D target <- 0.25
> ##D skeleton <- c(0.05, 0.15, 0.25, 0.4, 0.6)
> ##D paths <- crm_path_analysis(
> ##D   outcome_str = '1NNN 2NTN 2NNN',
> ##D   skeleton = skeleton, target = target, model = 'empiric',
> ##D   beta_sd = 1, seed = 123, refresh = 0)
> ##D length(paths)  # 4
> ##D names(paths)[1]  # ""
> ##D names(paths)[2]  # "1NNN"
> ##D names(paths)[3]  # "1NNN 2NTN"
> ##D names(paths)[4]  # "1NNN 2NTN 2NNN"
> ##D # Each node is an analysis fit to the cumulative outcomes
> ##D # Converting to a tibble presents some nice tidyverse-related opportunities
> ##D library(tibble)
> ##D df <- as_tibble(paths)
> ##D df
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("crm_prior_beliefs")
> ### * crm_prior_beliefs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: crm_prior_beliefs
> ### Title: Get the prior beliefs for a CRM trial scenario.
> ### Aliases: crm_prior_beliefs
> 
> ### ** Examples
> 
> skeleton <- c(0.05, 0.1, 0.15, 0.33, 0.5)
> target <- 0.33
> 
> prior_fit1 <- crm_prior_beliefs(skeleton, target, model = 'empiric',
+                                 beta_sd = sqrt(1.34))

SAMPLING FOR MODEL 'CrmEmpiricNormalPrior' NOW (CHAIN 1).
Chain 1: 
Chain 1: Gradient evaluation took 7.8e-05 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.78 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 0.004 seconds (Warm-up)
Chain 1:                0.004 seconds (Sampling)
Chain 1:                0.008 seconds (Total)
Chain 1: 

SAMPLING FOR MODEL 'CrmEmpiricNormalPrior' NOW (CHAIN 2).
Chain 2: 
Chain 2: Gradient evaluation took 2e-06 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.02 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 0.004 seconds (Warm-up)
Chain 2:                0.004 seconds (Sampling)
Chain 2:                0.008 seconds (Total)
Chain 2: 

SAMPLING FOR MODEL 'CrmEmpiricNormalPrior' NOW (CHAIN 3).
Chain 3: 
Chain 3: Gradient evaluation took 1e-06 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.01 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 0.004 seconds (Warm-up)
Chain 3:                0.004 seconds (Sampling)
Chain 3:                0.008 seconds (Total)
Chain 3: 

SAMPLING FOR MODEL 'CrmEmpiricNormalPrior' NOW (CHAIN 4).
Chain 4: 
Chain 4: Gradient evaluation took 1e-06 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0.01 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 0.004 seconds (Warm-up)
Chain 4:                0.004 seconds (Sampling)
Chain 4:                0.008 seconds (Total)
Chain 4: 
> prior_fit2 <- crm_prior_beliefs(skeleton, target, model = 'logistic_gamma',
+                                 a0 = 3, beta_shape = 1,
+                                 beta_inverse_scale = 2)

SAMPLING FOR MODEL 'CrmOneParamLogisticGammaPrior' NOW (CHAIN 1).
Chain 1: 
Chain 1: Gradient evaluation took 2e-06 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.02 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 0.009 seconds (Warm-up)
Chain 1:                0.017 seconds (Sampling)
Chain 1:                0.026 seconds (Total)
Chain 1: 

SAMPLING FOR MODEL 'CrmOneParamLogisticGammaPrior' NOW (CHAIN 2).
Chain 2: 
Chain 2: Gradient evaluation took 1e-06 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.01 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 0.01 seconds (Warm-up)
Chain 2:                0.006 seconds (Sampling)
Chain 2:                0.016 seconds (Total)
Chain 2: 

SAMPLING FOR MODEL 'CrmOneParamLogisticGammaPrior' NOW (CHAIN 3).
Chain 3: Rejecting initial value:
Chain 3:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 3:   Stan can't start sampling from this initial value.
Chain 3: Rejecting initial value:
Chain 3:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 3:   Stan can't start sampling from this initial value.
Chain 3: 
Chain 3: Gradient evaluation took 1e-06 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.01 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 0.009 seconds (Warm-up)
Chain 3:                0.004 seconds (Sampling)
Chain 3:                0.013 seconds (Total)
Chain 3: 

SAMPLING FOR MODEL 'CrmOneParamLogisticGammaPrior' NOW (CHAIN 4).
Chain 4: Rejecting initial value:
Chain 4:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 4:   Stan can't start sampling from this initial value.
Chain 4: 
Chain 4: Gradient evaluation took 1e-06 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0.01 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 0.009 seconds (Warm-up)
Chain 4:                0.009 seconds (Sampling)
Chain 4:                0.018 seconds (Total)
Chain 4: 
Warning: There were 1942 divergent transitions after warmup. See
https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup
to find out why this is a problem and how to eliminate them.
Warning: Examine the pairs() plot to diagnose sampling problems

Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable.
Running the chains for more iterations may help. See
https://mc-stan.org/misc/warnings.html#bulk-ess
Warning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable.
Running the chains for more iterations may help. See
https://mc-stan.org/misc/warnings.html#tail-ess
> 
> 
> 
> cleanEx()
> nameEx("df_parse_outcomes")
> ### * df_parse_outcomes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: df_parse_outcomes
> ### Title: Parse a string of dose-finding trial outcomes to binary vector
> ###   notation.
> ### Aliases: df_parse_outcomes
> 
> ### ** Examples
> 
> x = df_parse_outcomes('1NNN 2NTN 3TTT')
> x$num_patients  # 9
[1] 9
> x$doses         # c(1, 1, 1, 2, 2, 2, 3, 3, 3)
[1] 1 1 1 2 2 2 3 3 3
> x$tox           # c(0, 0, 0, 0, 1, 0, 1, 1, 1)
[1] 0 0 0 0 1 0 1 1 1
> sum(x$tox)      # 4
[1] 4
> 
> 
> 
> 
> cleanEx()
> nameEx("dose_finding_path_node-class")
> ### * dose_finding_path_node-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dose_finding_path_node-class
> ### Title: Class to hold the elements of a single dose-finding analysis
> ###   residing in a pathway of analyses.
> ### Aliases: dose_finding_path_node-class dose_finding_path_node
> 
> ### ** Examples
> 
> ## Not run: 
> ##D parent_outcomes <- '1NNN'
> ##D outcomes <- '1NNN 2NNT'
> ##D target <- 0.25
> ##D skeleton <- c(0.05, 0.15, 0.25, 0.4, 0.6)
> ##D parent_fit <- stan_crm(outcome_str = parent_outcomes, skeleton = skeleton,
> ##D                        target = target, model = 'empiric', beta_sd = 1)
> ##D fit <- stan_crm(outcome_str = outcomes, skeleton = skeleton,
> ##D                 target = target, model = 'empiric', beta_sd = 1)
> ##D dose_finding_path_node(node_id = 2, parent_node_id = 1, depth = 1,
> ##D                        outcomes = outcomes, next_dose = fit$recommended_dose,
> ##D                        fit = fit, parent_fit = parent_fit)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("eff_at_dose")
> ### * eff_at_dose
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eff_at_dose
> ### Title: Get the number of efficacy events seen at the doses under
> ###   investigation.
> ### Aliases: eff_at_dose eff_at_dose.efftox_fit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # EffTox example
> ##D x <- stan_efftox_demo(outcome_str = '1N 2E')
> ##D eff_at_dose(fit)            # c(0, 1, 0, 0)
> ##D eff_at_dose(fit, dose = 2)  # 1
> ##D eff_at_dose(fit, dose = 3)  # 0
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("efftox_analysis_to_df")
> ### * efftox_analysis_to_df
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: efftox_analysis_to_df
> ### Title: EffTox analysis to data.frame
> ### Aliases: efftox_analysis_to_df
> 
> ### ** Examples
> 
> fit <- stan_efftox_demo(outcome_str = '1N 2E 3B')

SAMPLING FOR MODEL 'EffTox' NOW (CHAIN 1).
Chain 1: 
Chain 1: Gradient evaluation took 2.9e-05 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.29 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 0.032 seconds (Warm-up)
Chain 1:                0.023 seconds (Sampling)
Chain 1:                0.055 seconds (Total)
Chain 1: 

SAMPLING FOR MODEL 'EffTox' NOW (CHAIN 2).
Chain 2: 
Chain 2: Gradient evaluation took 3e-06 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.03 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 0.031 seconds (Warm-up)
Chain 2:                0.023 seconds (Sampling)
Chain 2:                0.054 seconds (Total)
Chain 2: 

SAMPLING FOR MODEL 'EffTox' NOW (CHAIN 3).
Chain 3: 
Chain 3: Gradient evaluation took 5e-06 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.05 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 0.031 seconds (Warm-up)
Chain 3:                0.023 seconds (Sampling)
Chain 3:                0.054 seconds (Total)
Chain 3: 

SAMPLING FOR MODEL 'EffTox' NOW (CHAIN 4).
Chain 4: 
Chain 4: Gradient evaluation took 4e-06 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0.04 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 0.031 seconds (Warm-up)
Chain 4:                0.022 seconds (Sampling)
Chain 4:                0.053 seconds (Total)
Chain 4: 
> df <- efftox_analysis_to_df(fit)
> df
  Dose N   ProbEff    ProbTox ProbAccEff ProbAccTox     Utility Acceptable
1    1 1 0.2183731 0.04392999    0.15000    0.95675 -0.63753910       TRUE
2    2 1 0.5914880 0.08786880    0.63950    0.91575  0.03864061       TRUE
3    3 1 0.8958329 0.35042074    0.96725    0.52000  0.24220613       TRUE
4    4 0 0.9529364 0.62195121    0.98650    0.25175 -0.05846389       TRUE
5    5 0 0.9684537 0.74029934    0.98650    0.17175 -0.20789157      FALSE
  ProbOBD
1 0.03575
2 0.30900
3 0.45050
4 0.08275
5 0.12200
> 
> 
> 
> 
> cleanEx()
> nameEx("efftox_contour_plot")
> ### * efftox_contour_plot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: efftox_contour_plot
> ### Title: Plot EffTox utility contours
> ### Aliases: efftox_contour_plot
> 
> ### ** Examples
> 
> fit <- stan_efftox_demo(outcome_str = '1N 2E 3B')

SAMPLING FOR MODEL 'EffTox' NOW (CHAIN 1).
Chain 1: 
Chain 1: Gradient evaluation took 6e-06 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.06 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 0.032 seconds (Warm-up)
Chain 1:                0.024 seconds (Sampling)
Chain 1:                0.056 seconds (Total)
Chain 1: 

SAMPLING FOR MODEL 'EffTox' NOW (CHAIN 2).
Chain 2: 
Chain 2: Gradient evaluation took 4e-06 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.04 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 0.031 seconds (Warm-up)
Chain 2:                0.023 seconds (Sampling)
Chain 2:                0.054 seconds (Total)
Chain 2: 

SAMPLING FOR MODEL 'EffTox' NOW (CHAIN 3).
Chain 3: 
Chain 3: Gradient evaluation took 4e-06 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.04 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 0.031 seconds (Warm-up)
Chain 3:                0.024 seconds (Sampling)
Chain 3:                0.055 seconds (Total)
Chain 3: 

SAMPLING FOR MODEL 'EffTox' NOW (CHAIN 4).
Chain 4: 
Chain 4: Gradient evaluation took 4e-06 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0.04 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 0.031 seconds (Warm-up)
Chain 4:                0.022 seconds (Sampling)
Chain 4:                0.053 seconds (Total)
Chain 4: 
> efftox_contour_plot(fit)
> title('EffTox utility contours')
> # The same with ggplot2
> efftox_contour_plot(fit, use_ggplot = TRUE) +
+                     ggplot2::ggtitle('EffTox utility contours')
Warning: Removed 23133 rows containing missing values (`geom_line()`).
Warning: Removed 500 rows containing missing values (`geom_line()`).
> 
> 
> 
> 
> cleanEx()
> nameEx("efftox_dtps")
> ### * efftox_dtps
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: efftox_dtps
> ### Title: Calculate dose-transition pathways for an EffTox study
> ### Aliases: efftox_dtps
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Calculate paths for the first cohort of 3 in Thall et al 2014 example
> ##D paths1 <- efftox_dtps(cohort_sizes = c(3), next_dose = 1,
> ##D                       real_doses = c(1.0, 2.0, 4.0, 6.6, 10.0),
> ##D                       efficacy_hurdle = 0.5, toxicity_hurdle = 0.3,
> ##D                       p_e = 0.1, p_t = 0.1,
> ##D                       eff0 = 0.5, tox1 = 0.65,
> ##D                       eff_star = 0.7, tox_star = 0.25,
> ##D                       alpha_mean = -7.9593, alpha_sd = 3.5487,
> ##D                       beta_mean = 1.5482, beta_sd = 3.5018,
> ##D                       gamma_mean = 0.7367, gamma_sd = 2.5423,
> ##D                       zeta_mean = 3.4181, zeta_sd = 2.4406,
> ##D                       eta_mean = 0, eta_sd = 0.2,
> ##D                       psi_mean = 0, psi_sd = 1, seed = 123)
> ##D 
> ##D 
> ##D 
> ##D # Calculate paths for the next two cohorts of 2, in an in-progress trial
> ##D # Warning: this create 100 paths. It will run for a minute or two.
> ##D paths2 <- efftox_dtps(cohort_sizes = c(2, 2),
> ##D                       previous_outcomes = '1NN 2EE',
> ##D                       next_dose = 1,
> ##D                       real_doses = c(1.0, 2.0, 4.0, 6.6, 10.0),
> ##D                       efficacy_hurdle = 0.5, toxicity_hurdle = 0.3,
> ##D                       p_e = 0.1, p_t = 0.1,
> ##D                       eff0 = 0.5, tox1 = 0.65,
> ##D                       eff_star = 0.7, tox_star = 0.25,
> ##D                       alpha_mean = -7.9593, alpha_sd = 3.5487,
> ##D                       beta_mean = 1.5482, beta_sd = 3.5018,
> ##D                       gamma_mean = 0.7367, gamma_sd = 2.5423,
> ##D                       zeta_mean = 3.4181, zeta_sd = 2.4406,
> ##D                       eta_mean = 0, eta_sd = 0.2,
> ##D                       psi_mean = 0, psi_sd = 1, seed = 123,
> ##D                       i_am_patient = TRUE)
> ##D 
> ##D # Paths can be converted to a tibble
> ##D library(tibble)
> ##D library(dplyr)
> ##D df <- as_tibble(paths2)
> ##D df %>% print(n = 200)
> ##D 
> ##D # And shaped in a wide format
> ##D spread_paths(df %>% select(-fit, -parent_fit, -dose_index)) %>%
> ##D   print(n = 100)
> ##D # Incredibly, there are 100 ways these two cohorts of two can end up.
> ##D 
> ##D 
> ##D 
> ##D # An example with a custom dose selection function.
> ##D # Define a function to select the maximal utility dose, no matter what.
> ##D # Note: this diverges from the original authors' intentions; we provide this
> ##D # for illustration only!
> ##D max_utility_dose <- function(efftox_fit) {
> ##D   return(which.max(efftox_fit$utility))
> ##D }
> ##D # Fit the paths, providing the user_dose_func parameter
> ##D # Warning: this create 100 paths. It will run for a minute or two.
> ##D paths3 <- efftox_dtps(cohort_sizes = c(2, 2),
> ##D                       previous_outcomes = '1NN 2EE',
> ##D                       next_dose = 1,
> ##D                       real_doses = c(1.0, 2.0, 4.0, 6.6, 10.0),
> ##D                       efficacy_hurdle = 0.5, toxicity_hurdle = 0.3,
> ##D                       p_e = 0.1, p_t = 0.1,
> ##D                       eff0 = 0.5, tox1 = 0.65,
> ##D                       eff_star = 0.7, tox_star = 0.25,
> ##D                       alpha_mean = -7.9593, alpha_sd = 3.5487,
> ##D                       beta_mean = 1.5482, beta_sd = 3.5018,
> ##D                       gamma_mean = 0.7367, gamma_sd = 2.5423,
> ##D                       zeta_mean = 3.4181, zeta_sd = 2.4406,
> ##D                       eta_mean = 0, eta_sd = 0.2,
> ##D                       psi_mean = 0, psi_sd = 1,
> ##D                       user_dose_func = max_utility_dose,
> ##D                       seed = 123, i_am_patient = TRUE)
> ##D 
> ##D # We can see where the dose-selections differ at the second future cohort
> ##D # by joining these paths to those calculated in the previous example:
> ##D left_join(
> ##D   as_tibble(paths2)%>%
> ##D     select(.node, .parent, .depth, outcomes, model_dose = next_dose),
> ##D   as_tibble(paths3) %>%
> ##D     select(.node, user_dose = next_dose),
> ##D   by = '.node'
> ##D ) %>% spread_paths() %>%
> ##D   filter(model_dose2 != user_dose2)
> ##D # They differ in many places. The user defined functions sometimes selects
> ##D # higher doses; sometimes lower.
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("efftox_dtps_to_dataframe")
> ### * efftox_dtps_to_dataframe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: efftox_dtps_to_dataframe
> ### Title: Calculate dose-transition pathways for an EffTox study
> ### Aliases: efftox_dtps_to_dataframe
> 
> ### ** Examples
> 
> # Calculate the paths for the first cohort of 3 in Thall et al 2014 example
> dat <- efftox_parameters_demo()
> ## Not run: 
> ##D dtps1 <- efftox_dtps_to_dataframe(dat = dat, cohort_sizes = c(3),
> ##D                                   next_dose = 1)
> ## End(Not run)
> # To calculate future paths in a partially-observed trial
> dat <- efftox_parameters_demo()
> dat$doses = array(c(1,1,1))
> dat$eff = array(c(0,0,0))
> dat$tox = array(c(1,1,1))
> dat$num_patients = 3
> ## Not run: 
> ##D dtps2 <- efftox_dtps_to_dataframe(dat = dat, cohort_sizes = c(3),
> ##D                                   next_dose = 1)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("efftox_get_tox")
> ### * efftox_get_tox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: efftox_get_tox
> ### Title: Get the Prob(Tox) for Prob(Eff) and utility pairs
> ### Aliases: efftox_get_tox
> 
> ### ** Examples
> 
> p <- efftox_solve_p(0.5, 0.65, 0.7, 0.25)
> 
> prob_tox <- efftox_get_tox(0.7, 0, p, eff0 = 0.5, tox1 = 0.65)
> round(prob_tox, 2) == 0.25
[1] TRUE
> 
> prob_tox <- efftox_get_tox(0.7, seq(-0.5, 0.25, by = 0.25), p, eff0 = 0.5,
+                            tox1 = 0.65)
> round(prob_tox, 2) == c(0.57, 0.41, 0.25, 0.09)
[1] TRUE TRUE TRUE TRUE
> 
> prob_tox <- efftox_get_tox(c(0.5, 0.7, 0.8), 0.25, p, eff0 = 0.5, tox1 = 0.65)
> round(prob_tox, 2) == c(NaN, 0.09, 0.22)
[1]   NA TRUE TRUE
> 
> prob_tox <- efftox_get_tox(c(0.5, 0.7, 0.8), c(-1, 0, 1), p, eff0 = 0.5,
+                            tox1 = 0.65)
> round(prob_tox, 2) == c(0.63, 0.25, NaN)
[1] TRUE TRUE   NA
> 
> 
> 
> 
> cleanEx()
> nameEx("efftox_parameters_demo")
> ### * efftox_parameters_demo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: efftox_parameters_demo
> ### Title: Get parameters to run the EffTox demo
> ### Aliases: efftox_parameters_demo
> 
> ### ** Examples
> 
> dat <- efftox_parameters_demo()
> names(dat)
 [1] "real_doses"      "num_doses"       "efficacy_hurdle" "toxicity_hurdle"
 [5] "p_e"             "p_t"             "p"               "eff0"           
 [9] "tox1"            "eff_star"        "tox_star"        "alpha_mean"     
[13] "alpha_sd"        "beta_mean"       "beta_sd"         "gamma_mean"     
[17] "gamma_sd"        "zeta_mean"       "zeta_sd"         "eta_mean"       
[21] "eta_sd"          "psi_mean"        "psi_sd"          "version"        
[25] "num_patients"   
> dat$real_doses == c(1, 2, 4, 6.6, 10)
[1] TRUE TRUE TRUE TRUE TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("efftox_parse_outcomes")
> ### * efftox_parse_outcomes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: efftox_parse_outcomes
> ### Title: Parse a string of EffTox outcomes to binary vector notation.
> ### Aliases: efftox_parse_outcomes
> 
> ### ** Examples
> 
> x = efftox_parse_outcomes('1NNE 2EEN 3TBB')
> x$num_patients == 9
[1] TRUE
> x$eff == c(0, 0, 1, 1, 1, 0, 0, 1, 1)
[1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
> sum(x$tox) == 3
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("efftox_path_analysis")
> ### * efftox_path_analysis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: efftox_path_analysis
> ### Title: Fit an EffTox model to the incrementally observed outcomes on a
> ###   trial pathway.
> ### Aliases: efftox_path_analysis
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # EffTox example
> ##D paths <- efftox_path_analysis(
> ##D   outcome_str = '1NNN 2NEN 3NEB',
> ##D   real_doses = c(1.0, 2.0, 4.0, 6.6, 10.0),
> ##D   efficacy_hurdle = 0.5, toxicity_hurdle = 0.3,
> ##D   p_e = 0.1, p_t = 0.1,
> ##D   eff0 = 0.5, tox1 = 0.65,
> ##D   eff_star = 0.7, tox_star = 0.25,
> ##D   alpha_mean = -7.9593, alpha_sd = 3.5487,
> ##D   beta_mean = 1.5482, beta_sd = 3.5018,
> ##D   gamma_mean = 0.7367, gamma_sd = 2.5423,
> ##D   zeta_mean = 3.4181, zeta_sd = 2.4406,
> ##D   eta_mean = 0, eta_sd = 0.2,
> ##D   psi_mean = 0, psi_sd = 1, seed = 123, refresh = 0)
> ##D 
> ##D length(paths)  # 4
> ##D names(paths)[1]  # ""
> ##D names(paths)[2]  # "1NNN"
> ##D names(paths)[3]  # "1NNN 2NEN"
> ##D names(paths)[4]  # "1NNN 2NEN 3NEB"
> ##D # Each node is an analysis fit to the cumulative outcomes
> ##D # Converting to a tibble presents some nice tidyverse-related opportunities
> ##D library(tibble)
> ##D df <- as_tibble(paths)
> ##D df
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("efftox_priors")
> ### * efftox_priors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: efftox_priors
> ### Title: Simple class to hold prior hyperparameters for the EffTox model.
> ### Aliases: efftox_priors
> 
> ### ** Examples
> 
> # The priors used in Thall et al. (2014)
> p <- efftox_priors(alpha_mean = -7.9593, alpha_sd = 3.5487,
+                    beta_mean = 1.5482, beta_sd = 3.5018,
+                    gamma_mean = 0.7367, gamma_sd = 2.5423,
+                    zeta_mean = 3.4181, zeta_sd = 2.4406,
+                    eta_mean = 0, eta_sd = 0.2,
+                    psi_mean = 0, psi_sd = 1)
> # The class exists simply to hold these twelve values.
> 
> 
> 
> cleanEx()
> nameEx("efftox_simulate")
> ### * efftox_simulate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: efftox_simulate
> ### Title: Run EffTox simulations
> ### Aliases: efftox_simulate
> 
> ### ** Examples
> 
> dat <- efftox_parameters_demo()
> set.seed(123)
> # Let's say we want to use only 2 chains. Extra args are passed to stan
> ## Not run: 
> ##D sims <- efftox_simulate(dat, num_sims = 10, first_dose = 1,
> ##D                         true_eff = c(0.20, 0.40, 0.60, 0.80, 0.90),
> ##D                         true_tox = c(0.05, 0.10, 0.15, 0.20, 0.40),
> ##D                         cohort_sizes = rep(3, 13),
> ##D                         chains = 2)
> ##D table(sims$recommended_dose) / length(sims$recommended_dose)
> ##D table(unlist(sims$doses_given)) / length(unlist(sims$doses_given))
> ##D table(unlist(sims$doses_given)) / length(sims$recommended_dose)
> ## End(Not run)
> # In real life, we would run thousands of iterations, not 10.
> # This is an example.
> 
> 
> 
> cleanEx()
> nameEx("efftox_solve_p")
> ### * efftox_solve_p
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: efftox_solve_p
> ### Title: Calculate the p-index for EffTox utility contours
> ### Aliases: efftox_solve_p
> 
> ### ** Examples
> 
> efftox_solve_p(0.5, 0.65, 0.7, 0.25)
[1] 0.9773632
> 
> 
> 
> 
> cleanEx()
> nameEx("efftox_superiority")
> ### * efftox_superiority
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: efftox_superiority
> ### Title: Get dose-superiority matrix in EffTox
> ### Aliases: efftox_superiority
> 
> ### ** Examples
> 
> fit <- stan_efftox_demo('1N 2E 3B')

SAMPLING FOR MODEL 'EffTox' NOW (CHAIN 1).
Chain 1: 
Chain 1: Gradient evaluation took 8e-06 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.08 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 0.039 seconds (Warm-up)
Chain 1:                0.023 seconds (Sampling)
Chain 1:                0.062 seconds (Total)
Chain 1: 

SAMPLING FOR MODEL 'EffTox' NOW (CHAIN 2).
Chain 2: 
Chain 2: Gradient evaluation took 6e-06 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.06 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 0.031 seconds (Warm-up)
Chain 2:                0.023 seconds (Sampling)
Chain 2:                0.054 seconds (Total)
Chain 2: 

SAMPLING FOR MODEL 'EffTox' NOW (CHAIN 3).
Chain 3: 
Chain 3: Gradient evaluation took 4e-06 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.04 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 0.031 seconds (Warm-up)
Chain 3:                0.023 seconds (Sampling)
Chain 3:                0.054 seconds (Total)
Chain 3: 

SAMPLING FOR MODEL 'EffTox' NOW (CHAIN 4).
Chain 4: 
Chain 4: Gradient evaluation took 4e-06 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0.04 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 0.032 seconds (Warm-up)
Chain 4:                0.022 seconds (Sampling)
Chain 4:                0.054 seconds (Total)
Chain 4: 
> sup_mat <- efftox_superiority(fit)
> 
> 
> 
> cleanEx()
> nameEx("efftox_utility")
> ### * efftox_utility
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: efftox_utility
> ### Title: Get the utility of efficacy & toxicity probability pairs
> ### Aliases: efftox_utility
> 
> ### ** Examples
> 
> p <- efftox_solve_p(0.5, 0.65, 0.7, 0.25)
> 
> u <- efftox_utility(p, 0.5, 0.65, prob_eff = 0.7, prob_tox = 0.25)
> round(u, 4) == 0
[1] TRUE
> 
> u <- efftox_utility(p, 0.5, 0.65, prob_eff = c(0.6, 0.7, 0.8),
+                     prob_tox = c(0.1, 0.2, 0.3))
> round(u, 2) == c(0.04, 0.08, 0.12)
[1] TRUE TRUE TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("efftox_utility_density_plot")
> ### * efftox_utility_density_plot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: efftox_utility_density_plot
> ### Title: Plot densities of EffTox dose utilities
> ### Aliases: efftox_utility_density_plot
> 
> ### ** Examples
> 
> fit <- stan_efftox_demo('1N 2E 3B')

SAMPLING FOR MODEL 'EffTox' NOW (CHAIN 1).
Chain 1: 
Chain 1: Gradient evaluation took 6e-06 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.06 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 0.032 seconds (Warm-up)
Chain 1:                0.023 seconds (Sampling)
Chain 1:                0.055 seconds (Total)
Chain 1: 

SAMPLING FOR MODEL 'EffTox' NOW (CHAIN 2).
Chain 2: 
Chain 2: Gradient evaluation took 5e-06 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.05 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 0.03 seconds (Warm-up)
Chain 2:                0.023 seconds (Sampling)
Chain 2:                0.053 seconds (Total)
Chain 2: 

SAMPLING FOR MODEL 'EffTox' NOW (CHAIN 3).
Chain 3: 
Chain 3: Gradient evaluation took 4e-06 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.04 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 0.031 seconds (Warm-up)
Chain 3:                0.023 seconds (Sampling)
Chain 3:                0.054 seconds (Total)
Chain 3: 

SAMPLING FOR MODEL 'EffTox' NOW (CHAIN 4).
Chain 4: 
Chain 4: Gradient evaluation took 3e-06 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0.03 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 0.031 seconds (Warm-up)
Chain 4:                0.022 seconds (Sampling)
Chain 4:                0.053 seconds (Total)
Chain 4: 
> efftox_utility_density_plot(fit) + ggplot2::ggtitle('My doses')  # Too busy?
> # Specify subset of doses to make plot less cluttered
> efftox_utility_density_plot(fit, doses = 1:3) + ggplot2::ggtitle('My doses')
> 
> 
> 
> 
> cleanEx()
> nameEx("get_efftox_priors")
> ### * get_efftox_priors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_efftox_priors
> ### Title: Get normal prior hyperparameters for the EffTox model.
> ### Aliases: get_efftox_priors
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Reproduce the priors calculated in Thall et al. (2014)
> ##D p <- get_efftox_priors(
> ##D   doses = c(1.0, 2.0, 4.0, 6.6, 10.0),
> ##D   pi_T = c(0.02, 0.04, 0.06, 0.08, 0.10), ess_T = 0.9,
> ##D   pi_E = c(0.2, 0.4, 0.6, 0.8, 0.9), ess_E = 0.9
> ##D )
> ##D p
> ##D # These are close to the published example. They do not match exactly because
> ##D # the process of deriving them is iterative.
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("n_at_dose")
> ### * n_at_dose
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: n_at_dose
> ### Title: Get the number of patients treated at the doses under
> ###   investigation.
> ### Aliases: n_at_dose n_at_dose.dose_finding_fit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # CRM example
> ##D target <- 0.2
> ##D fit <- stan_crm('1N 2N 3T', skeleton = c(0.1, 0.2, 0.35, 0.6),
> ##D                  target = target, model = 'empiric', beta_sd = sqrt(1.34),
> ##D                  seed = 123)
> ##D n_at_dose(fit)            # c(1, 1, 1, 0)
> ##D n_at_dose(fit, dose = 3)  # 1
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("parse_dose_finding_outcomes")
> ### * parse_dose_finding_outcomes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: parse_dose_finding_outcomes
> ### Title: Parse a string of dose-finding trial outcomes.
> ### Aliases: parse_dose_finding_outcomes
> 
> ### ** Examples
> 
> x = parse_dose_finding_outcomes('1NNN 2NNT 3TT')
> length(x)
[1] 3
> x[[1]]$dose
[1] 1
> x[[1]]$outcomes
[1] "NNN"
> x[[2]]$dose
[1] 2
> x[[2]]$outcomes
[1] "NNT"
> x[[3]]$dose
[1] 3
> x[[3]]$outcomes
[1] "TT"
> 
> 
> 
> 
> cleanEx()
> nameEx("parse_eff_tox_dose_finding_outcomes")
> ### * parse_eff_tox_dose_finding_outcomes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: parse_eff_tox_dose_finding_outcomes
> ### Title: Parse a string of phase I/II dose-finding trial outcomes.
> ### Aliases: parse_eff_tox_dose_finding_outcomes
> 
> ### ** Examples
> 
> x = parse_eff_tox_dose_finding_outcomes('1NEN 2ENT 3TB')
> length(x)
[1] 3
> x[[1]]$dose
[1] 1
> x[[1]]$outcomes
[1] "NEN"
> x[[2]]$dose
[1] 2
> x[[2]]$outcomes
[1] "ENT"
> x[[3]]$dose
[1] 3
> x[[3]]$outcomes
[1] "TB"
> 
> 
> 
> 
> cleanEx()
> nameEx("peps2_get_data")
> ### * peps2_get_data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: peps2_get_data
> ### Title: Get data to run the PePS2 trial example
> ### Aliases: peps2_get_data
> 
> ### ** Examples
> 
> ## Not run: 
> ##D set.seed(123)
> ##D dat <- peps2_get_data(num_patients = 60,
> ##D                       prob_eff = c(0.167, 0.192, 0.5, 0.091, 0.156, 0.439),
> ##D                       prob_tox = rep(0.1, 6),
> ##D                       eff_tox_or = rep(1, 6))
> ##D fit <- stan_peps2(
> ##D   eff = dat$eff,
> ##D   tox = dat$tox,
> ##D   cohorts = dat$cohorts
> ##D )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("peps2_process")
> ### * peps2_process
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: peps2_process
> ### Title: Process RStan samples from a BEBOP model fit to PePS2 data
> ### Aliases: peps2_process
> 
> ### ** Examples
> 
> set.seed(123)
> fit <- stan_peps2(
+   eff = c(0, 1, 0, 1, 0, 0),
+   tox = c(0, 0, 1, 1, 0, 0),
+   cohorts = c(3, 1, 1, 4, 5, 6)
+ )

SAMPLING FOR MODEL 'BebopInPeps2' NOW (CHAIN 1).
Chain 1: 
Chain 1: Gradient evaluation took 7e-06 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.07 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 0.025 seconds (Warm-up)
Chain 1:                0.024 seconds (Sampling)
Chain 1:                0.049 seconds (Total)
Chain 1: 

SAMPLING FOR MODEL 'BebopInPeps2' NOW (CHAIN 2).
Chain 2: 
Chain 2: Gradient evaluation took 6e-06 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.06 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 0.025 seconds (Warm-up)
Chain 2:                0.026 seconds (Sampling)
Chain 2:                0.051 seconds (Total)
Chain 2: 

SAMPLING FOR MODEL 'BebopInPeps2' NOW (CHAIN 3).
Chain 3: 
Chain 3: Gradient evaluation took 8e-06 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.08 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 0.025 seconds (Warm-up)
Chain 3:                0.023 seconds (Sampling)
Chain 3:                0.048 seconds (Total)
Chain 3: 

SAMPLING FOR MODEL 'BebopInPeps2' NOW (CHAIN 4).
Chain 4: 
Chain 4: Gradient evaluation took 5e-06 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0.05 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 0.026 seconds (Warm-up)
Chain 4:                0.024 seconds (Sampling)
Chain 4:                0.05 seconds (Total)
Chain 4: 
> decision <- peps2_process(fit)
> decision$Accept
[1] FALSE FALSE FALSE FALSE FALSE FALSE
> decision$ProbEff
[1] 0.4624444 0.1281011 0.1667374 0.4976283 0.1421950 0.2074796
> decision$ProbAccEff
[1] 0.9370 0.3445 0.5625 0.9225 0.3905 0.6030
> 
> 
> 
> 
> cleanEx()
> nameEx("prior_predictive_augbin_2t_1a")
> ### * prior_predictive_augbin_2t_1a
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prior_predictive_augbin_2t_1a
> ### Title: Sample data from the Augmented Binary model prior predictive
> ###   distribution.
> ### Aliases: prior_predictive_augbin_2t_1a
> 
> ### ** Examples
> 
> prior_predictive_augbin_2t_1a(num_samps = 1000,
+                               alpha_mean = 0, alpha_sd = 1,
+                               beta_mean = 0, beta_sd = 1,
+                               gamma_mean = 0, gamma_sd = 1,
+                               sigma_mean = 0, sigma_sd = 1,
+                               omega_lkj_eta = 1,
+                               alpha_d1_mean = 0, alpha_d1_sd = 1,
+                               gamma_d1_mean = 0, gamma_d1_sd = 1,
+                               alpha_d2_mean = 0, alpha_d2_sd = 1,
+                               gamma_d2_mean = 0, gamma_d2_sd = 1)
# A tibble: 1,000 × 9
      id    z0           z1            z2    y0     y1      y2  prob_d1  prob_d2
   <int> <dbl>        <dbl>         <dbl> <dbl>  <dbl>   <dbl>    <dbl>    <dbl>
 1     1  6.05     0.0131      0.323          0  -6.14  -2.93  0.000177 5.62e- 1
 2     2  5.57     0.000170    0.000278       0 -10.4   -9.91  0.985    3.04e- 1
 3     3  5.73 56718.       5835.             0   9.20   6.93  0.940    1   e+ 0
 4     4  6.55  2945.         75.9            0   6.11   2.45  0.999    1   e+ 0
 5     5  5.75    52.4        12.9            0   2.21   0.808 0.0931   1.00e+ 0
 6     6  7.63   562.       2123.             0   4.30   5.63  0.386    1   e+ 0
 7     7  5.59    72.5         4.52           0   2.56  -0.212 0.976    8.25e-46
 8     8  7.39     0.0902      0.000132       0  -4.41 -10.9   0.115    6.63e- 1
 9     9  6.54     0.000155    0.00000117     0 -10.6  -15.5   1.00     6.80e- 1
10    10  6.53     1.81        4.48           0  -1.28  -0.376 1.00     5.06e- 1
# ℹ 990 more rows
> 
> 
> 
> cleanEx()
> nameEx("prob_success")
> ### * prob_success
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prob_success
> ### Title: Calculate the probability of success.
> ### Aliases: prob_success prob_success.augbin_2t_1a_fit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- stan_augbin_demo()
> ##D prob_success(fit, y2_upper = log(0.7))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("prob_tox_exceeds")
> ### * prob_tox_exceeds
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prob_tox_exceeds
> ### Title: Calculate the probability that the rate of toxicity exceeds some
> ###   threshold
> ### Aliases: prob_tox_exceeds prob_tox_exceeds.dose_finding_fit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # CRM example
> ##D target <- 0.2
> ##D fit <- stan_crm('1N 2N 3T', skeleton = c(0.1, 0.2, 0.35, 0.6),
> ##D                  target = target, model = 'empiric', beta_sd = sqrt(1.34),
> ##D                  seed = 123)
> ##D prob_tox_exceeds(fit, target)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ranBin2")
> ### * ranBin2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ranBin2
> ### Title: Sample pairs of correlated binary events
> ### Aliases: ranBin2
> 
> ### ** Examples
> 
> probs <- c(0.8, 0.3)
> s <- ranBin2(1000, probs, psi=0.2)  # 1000 pairs of outcomes
> cor(s)  # Negatively correlated because psi < 1
           [,1]       [,2]
[1,]  1.0000000 -0.2828648
[2,] -0.2828648  1.0000000
> colMeans(s)  # Event rates as expected
[1] 0.802 0.312
> 
> 
> 
> cleanEx()
> nameEx("spread_paths")
> ### * spread_paths
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: spread_paths
> ### Title: Spread the information in dose_finding_paths object to a wide
> ###   data.frame format.
> ### Aliases: spread_paths
> 
> ### ** Examples
> 
> ## Not run: 
> ##D target <- 0.25
> ##D skeleton <- c(0.05, 0.15, 0.25, 0.4, 0.6)
> ##D paths <- crm_dtps(skeleton = skeleton, target = target, model = 'empiric',
> ##D                   cohort_sizes = c(1, 1), next_dose = 3, beta_sd = 1)
> ##D spread_paths(dose_finding_paths = paths)
> ##D 
> ##D df <- as_tibble(paths)
> ##D spread_paths(df)
> ##D spread_paths(df %>% select(-fit, -parent_fit, -dose_index))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("stan_augbin")
> ### * stan_augbin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stan_augbin
> ### Title: Fit Wason & Seaman's Augmented Binary model for tumour response.
> ### Aliases: stan_augbin
> 
> ### ** Examples
> 
> priors <- list(alpha_mean = 0, alpha_sd = 1,
+                beta_mean = 0, beta_sd = 1,
+                gamma_mean = 0, gamma_sd = 1,
+                sigma_mean = 0, sigma_sd = 1,
+                omega_lkj_eta = 1,
+                alpha_d1_mean = 0, alpha_d1_sd = 1,
+                gamma_d1_mean = 0, gamma_d1_sd = 1,
+                alpha_d2_mean = 0, alpha_d2_sd = 1,
+                gamma_d2_mean = 0, gamma_d2_sd = 1)
> # Scenario 1 of Table 1 in Wason & Seaman (2013)
> N <- 50
> sigma <- 1
> delta1 <- -0.356
> mu <- c(0.5 * delta1, delta1)
> Sigma = matrix(c(0.5 * sigma^2, 0.5 * sigma^2, 0.5 * sigma^2, sigma^2),
+                ncol = 2)
> alphaD <- -1.5
> gammaD <- 0
> set.seed(123456)
> y <- MASS::mvrnorm(n = N, mu, Sigma)
> z0 <- runif(N, min = 5, max = 10)
> z1 <- exp(y[, 1]) * z0
> z2 <- exp(y[, 2]) * z0
> d1 <- rbinom(N, size = 1, prob = gtools::inv.logit(alphaD + gammaD * z0))
> d2 <- rbinom(N, size = 1, prob = gtools::inv.logit(alphaD + gammaD * z1))
> tumour_size <- data.frame(z0, z1, z2) # Sizes in cm
> non_shrinkage_failure <- data.frame(d1, d2)
> # Fit
> ## Not run: 
> ##D fit <- stan_augbin(tumour_size, non_shrinkage_failure,
> ##D                    prior_params = priors, model = '2t-1a', seed = 123)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("stan_augbin_demo")
> ### * stan_augbin_demo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stan_augbin_demo
> ### Title: Simple helper function to demonstrate fitting of an Augmented
> ###   Binary model.
> ### Aliases: stan_augbin_demo
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- stan_augbin_demo()
> ##D # I told you it was simple.
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("stan_crm")
> ### * stan_crm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stan_crm
> ### Title: Fit a CRM model
> ### Aliases: stan_crm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # CRM example
> ##D fit1 <- stan_crm('1N 2N 3T', skeleton = c(0.1, 0.2, 0.35, 0.6),
> ##D                  target = 0.2, model = 'empiric', beta_sd = sqrt(1.34),
> ##D                  seed = 123)
> ##D 
> ##D fit2 <- stan_crm('1NNN 2NNN 3TTT', skeleton = c(0.1, 0.2, 0.35, 0.6),
> ##D                  target = 0.2, model = 'logistic', a0 = 3, beta_mean = 0,
> ##D                  beta_sd = sqrt(1.34), seed = 123)
> ##D 
> ##D # The seed is passed to the Stan sampler. The usual Stan sampler params like
> ##D # cores, iter, chains etc are passed on too via the ellipsis operator.
> ##D 
> ##D # TITE-CRM example, p.124 of Dose Finding by the CRM, Cheung (2010)
> ##D fit3 <-stan_crm(skeleton = c(0.05, 0.12, 0.25, 0.40, 0.55), target = 0.25,
> ##D                 doses_given = c(3, 3, 3, 3),
> ##D                 tox = c(0, 0, 0, 0),
> ##D                 weights = c(73, 66, 35, 28) / 126,
> ##D                 model = 'empiric', beta_sd = sqrt(1.34), seed = 123)
> ##D fit3$recommended_dose
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("stan_efftox")
> ### * stan_efftox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stan_efftox
> ### Title: Fit an EffTox model
> ### Aliases: stan_efftox
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # This model is presented in Thall et al. (2014).
> ##D p <- efftox_priors(alpha_mean = -7.9593, alpha_sd = 3.5487,
> ##D                   beta_mean = 1.5482, beta_sd = 3.5018,
> ##D                   gamma_mean = 0.7367, gamma_sd = 2.5423,
> ##D                   zeta_mean = 3.4181, zeta_sd = 2.4406,
> ##D                   eta_mean = 0, eta_sd = 0.2,
> ##D                   psi_mean = 0, psi_sd = 1)
> ##D mod1 <- stan_efftox('1N 2E 3B',
> ##D                     real_doses = c(1.0, 2.0, 4.0, 6.6, 10.0),
> ##D                     efficacy_hurdle = 0.5, toxicity_hurdle = 0.3,
> ##D                     p_e = 0.1, p_t = 0.1,
> ##D                     eff0 = 0.5, tox1 = 0.65,
> ##D                     eff_star = 0.7, tox_star = 0.25,
> ##D                     priors = p,
> ##D                     seed = 123)
> ##D 
> ##D # The above is a longhad version of:
> ##D mod2 <- stan_efftox_demo('1N 2E 3B', seed = 123)
> ##D 
> ##D # the seed is passed to the Stan sampler. The usual Stan sampler params like
> ##D # cores, iter, chains etc are passed on too via the ellipsis operator.
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("stan_efftox_demo")
> ### * stan_efftox_demo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stan_efftox_demo
> ### Title: Fit the EffTox model presented in Thall et al. (2014)
> ### Aliases: stan_efftox_demo
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # This model is presented in Thall et al. (2014)
> ##D mod2 <- stan_efftox_demo('1N 2E 3B', seed = 123)
> ##D 
> ##D # The seed is passed to the Stan sampler. The usual Stan sampler params like
> ##D # cores, iter, chains etc are passed on too via the ellipsis operator.
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("stan_hierarchical_response_thall")
> ### * stan_hierarchical_response_thall
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stan_hierarchical_response_thall
> ### Title: Fit the hierarchical response model described by Thall _et al._
> ###   (2003).
> ### Aliases: stan_hierarchical_response_thall
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Example from p.778 of Thall et al. (2003)
> ##D mod0 <- stan_hierarchical_response_thall(
> ##D   group_responses = c(0, 0, 1, 3, 5, 0, 1, 2, 0, 0),
> ##D   group_sizes = c(0, 2 ,1, 7, 5, 0, 2, 3, 1, 0),
> ##D   mu_mean = -1.3863,
> ##D   mu_sd = sqrt(1 / 0.1),
> ##D   tau_alpha = 2,
> ##D   tau_beta = 20)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("stan_nbg")
> ### * stan_nbg
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stan_nbg
> ### Title: Fit a Neuenschwander, Branson & Gsponer logit dose-finding model
> ### Aliases: stan_nbg
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Non-TITE example:
> ##D fit1 <- stan_nbg('1NNN 2NNN 3TTT', real_doses = c(10, 20, 50, 100, 200),
> ##D                  d_star = 200, target = 0.25,
> ##D                  alpha_mean = -1, alpha_sd = 2,
> ##D                  beta_mean = 0, beta_sd = 1,
> ##D                  seed = 123)
> ##D fit1$recommended_dose
> ##D 
> ##D # The seed is passed to the Stan sampler. The usual Stan sampler params like
> ##D # cores, iter, chains etc are passed on too via the ellipsis operator.
> ##D 
> ##D # TITE-CRM example
> ##D fit2 <-stan_nbg(real_doses = c(10, 20, 50, 100, 200), d_star = 200,
> ##D                 target = 0.25,
> ##D                 doses_given = c(3, 3, 3, 3),
> ##D                 tox = c(0, 0, 0, 0),
> ##D                 weights = c(73, 66, 35, 28) / 126,
> ##D                 alpha_mean = -1, alpha_sd = 2,
> ##D                 beta_mean = 0, beta_sd = 1,
> ##D                 seed = 123)
> ##D fit2$recommended_dose
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("stan_peps2")
> ### * stan_peps2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stan_peps2
> ### Title: Fit the P2TNE model developed for the PePS2 trial to some
> ###   outcomes.
> ### Aliases: stan_peps2
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- stan_peps2(
> ##D   eff = c(0, 1, 0, 1, 0, 0),
> ##D   tox = c(0, 0, 1, 1, 0, 0),
> ##D   cohorts = c(3, 1, 1, 4, 5, 6)
> ##D )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("total_weight_at_dose")
> ### * total_weight_at_dose
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: total_weight_at_dose
> ### Title: Get the total weight of patient outcomes at the doses under
> ###   investigation.
> ### Aliases: total_weight_at_dose total_weight_at_dose.default
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # CRM example
> ##D fit <- stan_crm(skeleton = c(0.1, 0.2, 0.35, 0.6), target = 0.2,
> ##D                 model = 'empiric', beta_sd = sqrt(1.34), seed = 123,
> ##D                 doses = c(1, 1, 2, 2, 2),
> ##D                 tox   = c(0, 0, 0, 0, 0),
> ##D                 weights = c(1, 1, 0.9, 0.1, 0.1))
> ##D 
> ##D total_weight_at_dose(fit)            # c(2, 1.1, 0, 0)
> ##D total_weight_at_dose(fit, dose = 2)  # 1.1
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("tox_at_dose")
> ### * tox_at_dose
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tox_at_dose
> ### Title: Get the number of toxicity events seen at the doses under
> ###   investigation.
> ### Aliases: tox_at_dose tox_at_dose.dose_finding_fit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # CRM example
> ##D target <- 0.2
> ##D fit <- stan_crm('1N 2N 3T', skeleton = c(0.1, 0.2, 0.35, 0.6),
> ##D                  target = target, model = 'empiric', beta_sd = sqrt(1.34),
> ##D                  seed = 123)
> ##D tox_at_dose(fit)            # c(0, 0, 1, 0)
> ##D tox_at_dose(fit, dose = 3)  # 1
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("trialr_simulate")
> ### * trialr_simulate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trialr_simulate
> ### Title: Run a simulation study.
> ### Aliases: trialr_simulate
> 
> ### ** Examples
> 
> get_data_func <- function() {
+   group_sizes <- rbinom(n = 5, size = 50, prob = c(0.1, 0.3, 0.3, 0.2, 0.1))
+   group_responses <- rbinom(n = 5, size = group_sizes,
+                             prob = c(0.2, 0.5, 0.2, 0.2, 0.2))
+   list(
+     group_responses = group_responses, group_sizes = group_sizes,
+     mu_mean = gtools::logit(0.1), mu_sd = 1, tau_alpha = 2, tau_beta = 20
+   )
+ }
> fit_model_func <- function(data) {
+   data <- append(data, list(refresh = 0))
+   do.call(stan_hierarchical_response_thall, args = data)
+ }
> summarise_func <- function(data, fit) {
+   # Probability that estimate response rate exceeds 30%
+   unname(colMeans(as.data.frame(fit, 'prob_response') > 0.3))
+ }
> ## Not run: 
> ##D sims <- trialr_simulate(N = 20, get_data_func, fit_model_func, summarise_func)
> ##D # Posterior probabilities that the response rate in each cohort exceeds 30%:
> ##D do.call(rbind, sims)
> ##D # Cohorts are in columns; simulated iterations are in rows.
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("weights_at_dose")
> ### * weights_at_dose
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: weights_at_dose
> ### Title: Get the weights of patient outcomes at the doses under
> ###   investigation.
> ### Aliases: weights_at_dose weights_at_dose.default
> ###   weights_at_dose.crm_fit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # CRM example
> ##D fit <- stan_crm(skeleton = c(0.1, 0.2, 0.35, 0.6), target = 0.2,
> ##D                 model = 'empiric', beta_sd = sqrt(1.34), seed = 123,
> ##D                 doses = c(1, 1, 2, 2, 2),
> ##D                 tox   = c(0, 0, 0, 0, 0),
> ##D                 weights = c(1, 1, 0.9, 0.1, 0.1))
> ##D l <- weights_at_dose(fit)
> ##D 
> ##D length(l)  # 4
> ##D l[[1]]  # c(1, 1)
> ##D l[[2]]  # c(0.9, 0.1, 0.1)
> ##D l[[3]]  # c()
> ##D 
> ##D weights_at_dose(fit, dose = 2)  # c(0.9, 0.1, 0.1)
> ## End(Not run)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  4.766 0.118 4.902 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
