
R version 4.3.1 (2023-06-16) -- "Beagle Scouts"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin20 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "bench"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('bench')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("as_bench_time")
> ### * as_bench_time
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_bench_time
> ### Title: Human readable times
> ### Aliases: as_bench_time
> 
> ### ** Examples
> 
> as_bench_time("1ns")
[1] 1ns
> as_bench_time("1")
[1] 1s
> as_bench_time("1us")
[1] 1µs
> as_bench_time("1ms")
[1] 1ms
> as_bench_time("1s")
[1] 1s
> 
> as_bench_time("100ns") < "1ms"
[1] TRUE
> 
> sum(as_bench_time(c("1MB", "5MB", "500KB")))
[1] NA
> 
> 
> 
> cleanEx()
> nameEx("autoplot.bench_mark")
> ### * autoplot.bench_mark
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: autoplot.bench_mark
> ### Title: Autoplot method for bench_mark objects
> ### Aliases: autoplot.bench_mark plot.bench_mark
> 
> ### ** Examples
> 
> dat <- data.frame(x = runif(10000, 1, 1000), y=runif(10000, 1, 1000))
> 
> res <- bench::mark(
+   dat[dat$x > 500, ],
+   dat[which(dat$x > 500), ],
+   subset(dat, x > 500))
> 
> if (require(ggplot2) && require(tidyr) && require(ggbeeswarm)) {
+ 
+   # Beeswarm plot
+   autoplot(res)
+ 
+   # ridge (joyplot)
+   autoplot(res, "ridge")
+ 
+   # If you want to have the plots ordered by execution time you can do so by
+   # ordering factor levels in the expressions.
+   if (require(dplyr) && require(forcats)) {
+ 
+     res %>%
+       mutate(expression = forcats::fct_reorder(as.character(expression), min, .desc = TRUE)) %>%
+       as_bench_mark() %>%
+       autoplot("violin")
+   }
+ }
Loading required package: ggplot2
Loading required package: tidyr
Loading required package: ggbeeswarm
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Loading required package: forcats
> 
> 
> 
> cleanEx()

detaching ‘package:forcats’, ‘package:dplyr’, ‘package:ggbeeswarm’,
  ‘package:tidyr’, ‘package:ggplot2’

> nameEx("bench-package")
> ### * bench-package
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bench-package
> ### Title: bench: High Precision Timing of R Expressions
> ### Aliases: bench bench-package
> ### Keywords: internal
> 
> ### ** Examples
> 
> dat <- data.frame(x = runif(10000, 1, 1000), y=runif(10000, 1, 1000))
> 
> # `bench::mark()` implicitly calls summary() automatically
> results <- bench::mark(
+   dat[dat$x > 500, ],
+   dat[which(dat$x > 500), ],
+   subset(dat, x > 500))
> 
> # However you can also do so explicitly to filter gc differently.
> summary(results, filter_gc = FALSE)
# A tibble: 3 × 13
  expression      min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time
  <bch:expr>    <bch> <bch:>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm>
1 dat[dat$x > … 152µs  172µs     4776.     376KB     36.0  2388    18      500ms
2 dat[which(da… 134µs  150µs     5954.     259KB     31.8  2995    16      503ms
3 subset(dat, … 205µs  238µs     3327.     493KB     32.0  1664    16      500ms
# ℹ 4 more variables: result <list>, memory <list>, time <list>, gc <list>
> 
> # Or output relative times
> summary(results, relative = TRUE)
# A tibble: 3 × 13
  expression      min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time
  <bch:expr>    <dbl>  <dbl>     <dbl>     <dbl>    <dbl> <int> <dbl>   <bch:tm>
1 dat[dat$x > …  1.14   1.14      1.37      1.45     1.22  2370    18      415ms
2 dat[which(da…  1      1         1.59      1        1     2979    16      449ms
3 subset(dat, …  1.54   1.58      1         1.91     1.13  1648    16      396ms
# ℹ 4 more variables: result <list>, memory <list>, time <list>, gc <list>
> 
> 
> 
> cleanEx()
> nameEx("bench_bytes")
> ### * bench_bytes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bench_bytes
> ### Title: Human readable memory sizes
> ### Aliases: bench_bytes as_bench_bytes
> 
> ### ** Examples
> 
> bench_bytes("1")
[1] 1B
> bench_bytes("1K")
[1] 1KB
> bench_bytes("1Kb")
[1] 1KB
> bench_bytes("1KiB")
[1] 1KB
> bench_bytes("1MB")
[1] 1MB
> 
> bench_bytes("1KB") < "1MB"
[1] TRUE
> 
> sum(bench_bytes(c("1MB", "5MB", "500KB")))
[1] 6.49MB
> 
> 
> 
> cleanEx()
> nameEx("bench_memory")
> ### * bench_memory
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bench_memory
> ### Title: Measure memory that an expression used.
> ### Aliases: bench_memory
> 
> ### ** Examples
> 
> if (capabilities("profmem")) {
+   bench_memory(1 + 1:10000)
+ }
# A tibble: 1 × 2
  mem_alloc memory            
  <bch:byt> <list>            
1     117KB <Rprofmem [2 × 3]>
> 
> 
> 
> cleanEx()
> nameEx("bench_time")
> ### * bench_time
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bench_time
> ### Title: Measure Process CPU and real time that an expression used.
> ### Aliases: bench_time system_time
> 
> ### ** Examples
> 
> # This will use ~.5 seconds of real time, but very little process time.
> bench_time(Sys.sleep(.5))
process    real 
   28µs   494ms 
> 
> 
> 
> cleanEx()
> nameEx("hires_time")
> ### * hires_time
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hires_time
> ### Title: Return the current high-resolution real time.
> ### Aliases: hires_time
> 
> ### ** Examples
> 
> hires_time()
[1] 195357.2
> 
> # R rounds doubles to 7 digits by default, see greater precision by setting
> # the digits argument when printing
> print(hires_time(), digits = 20)
[1] 195357.22857205700711
> 
> # Generally used by recording two times and then subtracting them
> start <- hires_time()
> end <- hires_time()
> elapsed <- end - start
> elapsed
[1] 2.341098e-05
> 
> 
> 
> cleanEx()
> nameEx("mark")
> ### * mark
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mark
> ### Title: Benchmark a series of functions
> ### Aliases: mark bench_mark
> 
> ### ** Examples
> 
> dat <- data.frame(x = runif(100, 1, 1000), y=runif(10, 1, 1000))
> mark(
+   min_time = .1,
+ 
+   dat[dat$x > 500, ],
+   dat[which(dat$x > 500), ],
+   subset(dat, x > 500))
# A tibble: 3 × 13
  expression      min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time
  <bch:expr>   <bch:> <bch:>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm>
1 dat[dat$x >… 12.1µs   13µs    74104.     4.1KB     58.2  6364     5     85.9ms
2 dat[which(d… 12.5µs 13.7µs    71201.    2.74KB     57.0  6251     5     87.8ms
3 subset(dat,…   21µs 22.7µs    42889.    5.41KB     46.4  3696     4     86.2ms
# ℹ 4 more variables: result <list>, memory <list>, time <list>, gc <list>
> 
> 
> 
> cleanEx()
> nameEx("press")
> ### * press
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: press
> ### Title: Run setup code and benchmarks across a grid of parameters
> ### Aliases: press
> 
> ### ** Examples
> 
> # Helper function to create a simple data.frame of the specified dimensions
> create_df <- function(rows, cols) {
+   as.data.frame(setNames(
+     replicate(cols, runif(rows, 1, 1000), simplify = FALSE),
+     rep_len(c("x", letters), cols)))
+ }
> 
> # Run 4 data sizes across 3 samples with 2 replicates (24 total benchmarks)
> press(
+   rows = c(1000, 10000),
+   cols = c(10, 100),
+   rep = 1:2,
+   {
+     dat <- create_df(rows, cols)
+     bench::mark(
+       min_time = .05,
+       bracket = dat[dat$x > 500, ],
+       which = dat[which(dat$x > 500), ],
+       subset = subset(dat, x > 500)
+     )
+   }
+ )
Running with:
   rows  cols   rep
1  1000    10     1
2 10000    10     1
3  1000   100     1
4 10000   100     1
5  1000    10     2
6 10000    10     2
7  1000   100     2
8 10000   100     2
# A tibble: 24 × 16
   expression  rows  cols   rep      min   median `itr/sec` mem_alloc `gc/sec`
   <bch:expr> <dbl> <dbl> <int> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>
 1 bracket     1000    10     1  52.15µs  57.93µs    16850.   112.6KB     48.6
 2 which       1000    10     1  50.43µs  54.37µs    17908.   53.77KB     21.2
 3 subset      1000    10     1  64.21µs  72.73µs    13611.  124.46KB     46.9
 4 bracket    10000    10     1  392.7µs 431.18µs     2286.    1.13MB     71.4
 5 which      10000    10     1 249.81µs 282.43µs     3513.  573.48KB     45.0
 6 subset     10000    10     1 454.32µs 491.34µs     1999.    1.25MB     47.0
 7 bracket     1000   100     1 421.77µs 477.59µs     2073.  1002.7KB     74.0
 8 which       1000   100     1 386.43µs 413.85µs     2392.  408.16KB     43.9
 9 subset      1000   100     1 456.33µs 508.97µs     1739. 1023.91KB     46.4
10 bracket    10000   100     1   3.28ms   3.49ms      284.    9.86MB    397. 
# ℹ 14 more rows
# ℹ 7 more variables: n_itr <int>, n_gc <dbl>, total_time <bch:tm>,
#   result <list>, memory <list>, time <list>, gc <list>
> 
> 
> 
> cleanEx()
> nameEx("summary.bench_mark")
> ### * summary.bench_mark
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.bench_mark
> ### Title: Summarize mark results.
> ### Aliases: summary.bench_mark
> 
> ### ** Examples
> 
> dat <- data.frame(x = runif(10000, 1, 1000), y=runif(10000, 1, 1000))
> 
> # `bench::mark()` implicitly calls summary() automatically
> results <- bench::mark(
+   dat[dat$x > 500, ],
+   dat[which(dat$x > 500), ],
+   subset(dat, x > 500))
> 
> # However you can also do so explicitly to filter gc differently.
> summary(results, filter_gc = FALSE)
# A tibble: 3 × 13
  expression      min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time
  <bch:expr>    <bch> <bch:>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm>
1 dat[dat$x > … 143µs  162µs     5148.     376KB     50.0  2574    25      500ms
2 dat[which(da… 133µs  147µs     6141.     259KB     38.0  3070    19      500ms
3 subset(dat, … 197µs  230µs     3795.     493KB     46.0  1898    23      500ms
# ℹ 4 more variables: result <list>, memory <list>, time <list>, gc <list>
> 
> # Or output relative times
> summary(results, relative = TRUE)
# A tibble: 3 × 13
  expression      min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time
  <bch:expr>    <dbl>  <dbl>     <dbl>     <dbl>    <dbl> <int> <dbl>   <bch:tm>
1 dat[dat$x > …  1.07   1.10      1.35      1.45     1.36  2549    25      435ms
2 dat[which(da…  1      1         1.56      1        1     3051    19      450ms
3 subset(dat, …  1.48   1.56      1         1.91     1.26  1875    23      433ms
# ℹ 4 more variables: result <list>, memory <list>, time <list>, gc <list>
> 
> 
> 
> cleanEx()
> nameEx("workout")
> ### * workout
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: workout
> ### Title: Workout a group of expressions individually
> ### Aliases: workout workout_expressions
> 
> ### ** Examples
> 
> workout({
+   x <- 1:1000
+   evens <- x %% 2 == 0
+   y <- x[evens]
+   length(y)
+   length(which(evens))
+   sum(evens)
+ })
# A tibble: 6 × 3
  exprs                 process     real
  <bch:expr>           <bch:tm> <bch:tm>
1 x <- 1:1000               2µs    2.3µs
2 evens <- x%%2 == 0        9µs   9.27µs
3 y <- x[evens]             3µs   3.44µs
4 length(y)                 1µs 778.99ns
5 length(which(evens))      3µs   3.32µs
6 sum(evens)                2µs   1.72µs
> 
> # The equivalent to the above, reading the code from a file
> workout_expressions(as.list(parse(system.file("examples/exprs.R", package = "bench"))))
# A tibble: 6 × 3
  exprs                 process     real
  <bch:expr>           <bch:tm> <bch:tm>
1 x <- 1:1000               2µs   3.12µs
2 evens <- x%%2 == 0        7µs   7.54µs
3 y <- x[evens]             4µs   3.53µs
4 length(y)                 1µs 738.01ns
5 length(which(evens))      3µs    3.4µs
6 sum(evens)                1µs   1.64µs
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  6.336 0.831 7.795 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
