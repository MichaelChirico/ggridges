
R version 4.3.1 (2023-06-16) -- "Beagle Scouts"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin20 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "bench"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('bench')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("as_bench_time")
> ### * as_bench_time
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_bench_time
> ### Title: Human readable times
> ### Aliases: as_bench_time
> 
> ### ** Examples
> 
> as_bench_time("1ns")
[1] 1ns
> as_bench_time("1")
[1] 1s
> as_bench_time("1us")
[1] 1µs
> as_bench_time("1ms")
[1] 1ms
> as_bench_time("1s")
[1] 1s
> 
> as_bench_time("100ns") < "1ms"
[1] TRUE
> 
> sum(as_bench_time(c("1MB", "5MB", "500KB")))
[1] NA
> 
> 
> 
> cleanEx()
> nameEx("autoplot.bench_mark")
> ### * autoplot.bench_mark
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: autoplot.bench_mark
> ### Title: Autoplot method for bench_mark objects
> ### Aliases: autoplot.bench_mark plot.bench_mark
> 
> ### ** Examples
> 
> dat <- data.frame(x = runif(10000, 1, 1000), y=runif(10000, 1, 1000))
> 
> res <- bench::mark(
+   dat[dat$x > 500, ],
+   dat[which(dat$x > 500), ],
+   subset(dat, x > 500))
> 
> if (require(ggplot2) && require(tidyr) && require(ggbeeswarm)) {
+ 
+   # Beeswarm plot
+   autoplot(res)
+ 
+   # ridge (joyplot)
+   autoplot(res, "ridge")
+ 
+   # If you want to have the plots ordered by execution time you can do so by
+   # ordering factor levels in the expressions.
+   if (require(dplyr) && require(forcats)) {
+ 
+     res %>%
+       mutate(expression = forcats::fct_reorder(as.character(expression), min, .desc = TRUE)) %>%
+       as_bench_mark() %>%
+       autoplot("violin")
+   }
+ }
Loading required package: ggplot2
Loading required package: tidyr
Loading required package: ggbeeswarm
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Loading required package: forcats
> 
> 
> 
> cleanEx()

detaching ‘package:forcats’, ‘package:dplyr’, ‘package:ggbeeswarm’,
  ‘package:tidyr’, ‘package:ggplot2’

> nameEx("bench-package")
> ### * bench-package
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bench-package
> ### Title: bench: High Precision Timing of R Expressions
> ### Aliases: bench bench-package
> ### Keywords: internal
> 
> ### ** Examples
> 
> dat <- data.frame(x = runif(10000, 1, 1000), y=runif(10000, 1, 1000))
> 
> # `bench::mark()` implicitly calls summary() automatically
> results <- bench::mark(
+   dat[dat$x > 500, ],
+   dat[which(dat$x > 500), ],
+   subset(dat, x > 500))
> 
> # However you can also do so explicitly to filter gc differently.
> summary(results, filter_gc = FALSE)
# A tibble: 3 × 13
  expression      min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time
  <bch:expr>    <bch> <bch:>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm>
1 dat[dat$x > … 147µs  170µs     5083.     376KB     38.0  2541    19      500ms
2 dat[which(da… 128µs  145µs     6081.     259KB     32.0  3040    16      500ms
3 subset(dat, … 197µs  227µs     3460.     493KB     34.0  1730    17      500ms
# ℹ 4 more variables: result <list>, memory <list>, time <list>, gc <list>
> 
> # Or output relative times
> summary(results, relative = TRUE)
# A tibble: 3 × 13
  expression      min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time
  <bch:expr>    <dbl>  <dbl>     <dbl>     <dbl>    <dbl> <int> <dbl>   <bch:tm>
1 dat[dat$x > …  1.15   1.17      1.35      1.45     1.21  2522    19      433ms
2 dat[which(da…  1      1         1.59      1        1     3024    16      443ms
3 subset(dat, …  1.54   1.56      1         1.91     1.18  1713    17      399ms
# ℹ 4 more variables: result <list>, memory <list>, time <list>, gc <list>
> 
> 
> 
> cleanEx()
> nameEx("bench_bytes")
> ### * bench_bytes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bench_bytes
> ### Title: Human readable memory sizes
> ### Aliases: bench_bytes as_bench_bytes
> 
> ### ** Examples
> 
> bench_bytes("1")
[1] 1B
> bench_bytes("1K")
[1] 1KB
> bench_bytes("1Kb")
[1] 1KB
> bench_bytes("1KiB")
[1] 1KB
> bench_bytes("1MB")
[1] 1MB
> 
> bench_bytes("1KB") < "1MB"
[1] TRUE
> 
> sum(bench_bytes(c("1MB", "5MB", "500KB")))
[1] 6.49MB
> 
> 
> 
> cleanEx()
> nameEx("bench_memory")
> ### * bench_memory
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bench_memory
> ### Title: Measure memory that an expression used.
> ### Aliases: bench_memory
> 
> ### ** Examples
> 
> if (capabilities("profmem")) {
+   bench_memory(1 + 1:10000)
+ }
# A tibble: 1 × 2
  mem_alloc memory            
  <bch:byt> <list>            
1     117KB <Rprofmem [2 × 3]>
> 
> 
> 
> cleanEx()
> nameEx("bench_time")
> ### * bench_time
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bench_time
> ### Title: Measure Process CPU and real time that an expression used.
> ### Aliases: bench_time system_time
> 
> ### ** Examples
> 
> # This will use ~.5 seconds of real time, but very little process time.
> bench_time(Sys.sleep(.5))
process    real 
   24µs   497ms 
> 
> 
> 
> cleanEx()
> nameEx("hires_time")
> ### * hires_time
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hires_time
> ### Title: Return the current high-resolution real time.
> ### Aliases: hires_time
> 
> ### ** Examples
> 
> hires_time()
[1] 195377.5
> 
> # R rounds doubles to 7 digits by default, see greater precision by setting
> # the digits argument when printing
> print(hires_time(), digits = 20)
[1] 195377.45143071201164
> 
> # Generally used by recording two times and then subtracting them
> start <- hires_time()
> end <- hires_time()
> elapsed <- end - start
> elapsed
[1] 7.010996e-06
> 
> 
> 
> cleanEx()
> nameEx("mark")
> ### * mark
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mark
> ### Title: Benchmark a series of functions
> ### Aliases: mark bench_mark
> 
> ### ** Examples
> 
> dat <- data.frame(x = runif(100, 1, 1000), y=runif(10, 1, 1000))
> mark(
+   min_time = .1,
+ 
+   dat[dat$x > 500, ],
+   dat[which(dat$x > 500), ],
+   subset(dat, x > 500))
# A tibble: 3 × 13
  expression      min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time
  <bch:expr>   <bch:> <bch:>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm>
1 dat[dat$x >… 11.6µs 12.8µs    76403.     4.1KB     57.4  6658     5     87.1ms
2 dat[which(d… 12.1µs 13.1µs    75117.    2.74KB     57.3  6553     5     87.2ms
3 subset(dat,… 20.1µs 22.1µs    44674.    5.41KB     56.6  3946     5     88.3ms
# ℹ 4 more variables: result <list>, memory <list>, time <list>, gc <list>
> 
> 
> 
> cleanEx()
> nameEx("press")
> ### * press
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: press
> ### Title: Run setup code and benchmarks across a grid of parameters
> ### Aliases: press
> 
> ### ** Examples
> 
> # Helper function to create a simple data.frame of the specified dimensions
> create_df <- function(rows, cols) {
+   as.data.frame(setNames(
+     replicate(cols, runif(rows, 1, 1000), simplify = FALSE),
+     rep_len(c("x", letters), cols)))
+ }
> 
> # Run 4 data sizes across 3 samples with 2 replicates (24 total benchmarks)
> press(
+   rows = c(1000, 10000),
+   cols = c(10, 100),
+   rep = 1:2,
+   {
+     dat <- create_df(rows, cols)
+     bench::mark(
+       min_time = .05,
+       bracket = dat[dat$x > 500, ],
+       which = dat[which(dat$x > 500), ],
+       subset = subset(dat, x > 500)
+     )
+   }
+ )
Running with:
   rows  cols   rep
1  1000    10     1
2 10000    10     1
3  1000   100     1
4 10000   100     1
5  1000    10     2
6 10000    10     2
7  1000   100     2
8 10000   100     2
# A tibble: 24 × 16
   expression  rows  cols   rep      min   median `itr/sec` mem_alloc `gc/sec`
   <bch:expr> <dbl> <dbl> <int> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>
 1 bracket     1000    10     1  48.42µs  55.92µs    17886.   112.6KB     46.8
 2 which       1000    10     1  46.95µs  51.78µs    19212.   53.77KB     44.8
 3 subset      1000    10     1   59.9µs  68.88µs    14436.  124.46KB     21.5
 4 bracket    10000    10     1 383.64µs  429.8µs     2266.    1.13MB     45.8
 5 which      10000    10     1 239.32µs 265.02µs     3584.  573.48KB     46.9
 6 subset     10000    10     1 443.42µs 495.53µs     2001.    1.25MB     74.1
 7 bracket     1000   100     1 382.41µs 449.65µs     2262.  1002.7KB     74.6
 8 which       1000   100     1 365.19µs 391.71µs     2560.  408.16KB     44.9
 9 subset      1000   100     1 416.81µs 463.59µs     2169. 1023.91KB     47.2
10 bracket    10000   100     1   2.78ms   2.96ms      328.    9.86MB    524. 
# ℹ 14 more rows
# ℹ 7 more variables: n_itr <int>, n_gc <dbl>, total_time <bch:tm>,
#   result <list>, memory <list>, time <list>, gc <list>
> 
> 
> 
> cleanEx()
> nameEx("summary.bench_mark")
> ### * summary.bench_mark
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.bench_mark
> ### Title: Summarize mark results.
> ### Aliases: summary.bench_mark
> 
> ### ** Examples
> 
> dat <- data.frame(x = runif(10000, 1, 1000), y=runif(10000, 1, 1000))
> 
> # `bench::mark()` implicitly calls summary() automatically
> results <- bench::mark(
+   dat[dat$x > 500, ],
+   dat[which(dat$x > 500), ],
+   subset(dat, x > 500))
> 
> # However you can also do so explicitly to filter gc differently.
> summary(results, filter_gc = FALSE)
# A tibble: 3 × 13
  expression      min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time
  <bch:expr>    <bch> <bch:>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm>
1 dat[dat$x > … 140µs  162µs     5453.     376KB     53.8  2738    27      502ms
2 dat[which(da… 123µs  142µs     6357.     259KB     39.9  3188    20      502ms
3 subset(dat, … 200µs  226µs     3899.     493KB     46.0  1950    23      500ms
# ℹ 4 more variables: result <list>, memory <list>, time <list>, gc <list>
> 
> # Or output relative times
> summary(results, relative = TRUE)
# A tibble: 3 × 13
  expression      min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time
  <bch:expr>    <dbl>  <dbl>     <dbl>     <dbl>    <dbl> <int> <dbl>   <bch:tm>
1 dat[dat$x > …  1.14   1.13      1.40      1.45     1.39  2711    27      438ms
2 dat[which(da…  1      1         1.60      1        1     3168    20      450ms
3 subset(dat, …  1.63   1.59      1         1.91     1.19  1927    23      437ms
# ℹ 4 more variables: result <list>, memory <list>, time <list>, gc <list>
> 
> 
> 
> cleanEx()
> nameEx("workout")
> ### * workout
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: workout
> ### Title: Workout a group of expressions individually
> ### Aliases: workout workout_expressions
> 
> ### ** Examples
> 
> workout({
+   x <- 1:1000
+   evens <- x %% 2 == 0
+   y <- x[evens]
+   length(y)
+   length(which(evens))
+   sum(evens)
+ })
# A tibble: 6 × 3
  exprs                 process     real
  <bch:expr>           <bch:tm> <bch:tm>
1 x <- 1:1000               1µs   1.19µs
2 evens <- x%%2 == 0        8µs    8.2µs
3 y <- x[evens]             3µs   3.28µs
4 length(y)                   0 778.99ns
5 length(which(evens))      2µs   2.91µs
6 sum(evens)                1µs   1.56µs
> 
> # The equivalent to the above, reading the code from a file
> workout_expressions(as.list(parse(system.file("examples/exprs.R", package = "bench"))))
# A tibble: 6 × 3
  exprs                 process     real
  <bch:expr>           <bch:tm> <bch:tm>
1 x <- 1:1000               1µs    1.8µs
2 evens <- x%%2 == 0        6µs    6.6µs
3 y <- x[evens]             3µs   3.36µs
4 length(y)                   0 779.02ns
5 length(which(evens))      3µs   2.79µs
6 sum(evens)                1µs   1.48µs
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  6.299 0.786 7.686 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
