
R version 4.3.1 (2023-06-16) -- "Beagle Scouts"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin20 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "reservr"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('reservr')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Distribution")
> ### * Distribution
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Distribution
> ### Title: Base class for Distributions
> ### Aliases: Distribution
> 
> ### ** Examples
> 
> # Example for param_bounds:
> 
> # Create an Exponential Distribution with rate constrained to (0, 2)
> # instead of (0, Inf)
> my_exp <- dist_exponential()
> my_exp$param_bounds$rate <- interval(c(0, 2))
> my_exp$get_param_bounds()
$rate
(0, 2)

> 
> fit_dist(my_exp, rexp(100, rate = 3), start = list(rate = 1))$params$rate
[1] 2
> 
> 
> ## ------------------------------------------------
> ## Method `Distribution$sample`
> ## ------------------------------------------------
> 
> dist_exponential(rate = 2.0)$sample(10)
 [1] 0.9499217 0.2581031 0.2244989 0.1897998 0.6243838 1.3467058 0.0981609
 [8] 1.1499186 0.2828513 0.3815900
> 
> ## ------------------------------------------------
> ## Method `Distribution$density`
> ## ------------------------------------------------
> 
> dist_exponential()$density(c(1.0, 2.0), with_params = list(rate = 2.0))
[1] 0.27067057 0.03663128
> 
> ## ------------------------------------------------
> ## Method `Distribution$probability`
> ## ------------------------------------------------
> 
> dist_exponential()$probability(
+   c(1.0, 2.0),
+   with_params = list(rate = 2.0)
+ )
[1] 0.8646647 0.9816844
> 
> ## ------------------------------------------------
> ## Method `Distribution$quantile`
> ## ------------------------------------------------
> 
> dist_exponential()$quantile(c(0.1, 0.5), with_params = list(rate = 2.0))
[1] 0.05268026 0.34657359
> 
> ## ------------------------------------------------
> ## Method `Distribution$hazard`
> ## ------------------------------------------------
> 
> dist_exponential(rate = 2.0)$hazard(c(1.0, 2.0))
[1] 2 2
> 
> ## ------------------------------------------------
> ## Method `Distribution$diff_density`
> ## ------------------------------------------------
> 
> dist_exponential()$diff_density(
+   c(1.0, 2.0),
+   with_params = list(rate = 2.0)
+ )
$rate
[1] -0.13533528 -0.05494692

> 
> ## ------------------------------------------------
> ## Method `Distribution$diff_probability`
> ## ------------------------------------------------
> 
> dist_exponential()$diff_probability(
+   c(1.0, 2.0),
+   with_params = list(rate = 2.0)
+ )
$rate
[1] 0.13533528 0.03663128

> 
> ## ------------------------------------------------
> ## Method `Distribution$is_in_support`
> ## ------------------------------------------------
> 
> dist_exponential(rate = 1.0)$is_in_support(c(-1.0, 0.0, 1.0))
[1] FALSE FALSE  TRUE
> 
> ## ------------------------------------------------
> ## Method `Distribution$is_discrete_at`
> ## ------------------------------------------------
> 
> dist_dirac(point = 0.0)$is_discrete_at(c(0.0, 1.0))
[1]  TRUE FALSE
> 
> ## ------------------------------------------------
> ## Method `Distribution$has_capability`
> ## ------------------------------------------------
> 
> dist_exponential()$has_capability("density")
[1] TRUE
> 
> ## ------------------------------------------------
> ## Method `Distribution$get_type`
> ## ------------------------------------------------
> 
> dist_exponential()$get_type()
[1] "continuous"
> dist_dirac()$get_type()
[1] "discrete"
> 
> dist_mixture(list(dist_dirac(), dist_exponential()))$get_type()
[1] "mixed"
> dist_mixture(list(dist_dirac(), dist_binomial()))$get_type()
[1] "discrete"
> 
> ## ------------------------------------------------
> ## Method `Distribution$get_components`
> ## ------------------------------------------------
> 
> dist_trunc(dist_exponential())$get_components()
[[1]]
An ExponentialDistribution with 1 dof

> dist_dirac()$get_components()
list()
> dist_mixture(list(dist_exponential(), dist_gamma()))$get_components()
[[1]]
An ExponentialDistribution with 1 dof

[[2]]
A GammaDistribution with 2 dof

> 
> ## ------------------------------------------------
> ## Method `Distribution$is_discrete`
> ## ------------------------------------------------
> 
> dist_exponential()$is_discrete()
[1] FALSE
> dist_dirac()$is_discrete()
[1] TRUE
> 
> ## ------------------------------------------------
> ## Method `Distribution$is_continuous`
> ## ------------------------------------------------
> 
> dist_exponential()$is_continuous()
[1] TRUE
> dist_dirac()$is_continuous()
[1] FALSE
> 
> ## ------------------------------------------------
> ## Method `Distribution$require_capability`
> ## ------------------------------------------------
> 
> dist_exponential()$require_capability("diff_density")
> 
> ## ------------------------------------------------
> ## Method `Distribution$get_dof`
> ## ------------------------------------------------
> 
> dist_exponential()$get_dof()
[1] 1
> dist_exponential(rate = 1.0)$get_dof()
[1] 0
> 
> ## ------------------------------------------------
> ## Method `Distribution$get_placeholders`
> ## ------------------------------------------------
> 
> dist_exponential()$get_placeholders()
$rate
NULL

> dist_mixture(list(dist_dirac(), dist_exponential()))$get_placeholders()
$dists
$dists[[1]]
$dists[[1]]$point
NULL


$dists[[2]]
$dists[[2]]$rate
NULL



$probs
$probs[[1]]
NULL

$probs[[2]]
NULL


> 
> ## ------------------------------------------------
> ## Method `Distribution$get_params`
> ## ------------------------------------------------
> 
> dist_mixture(list(dist_dirac(), dist_exponential()))$get_params(
+   with_params = list(probs = list(0.5, 0.5))
+ )
$dists
$dists[[1]]
$dists[[1]]$point
NULL


$dists[[2]]
$dists[[2]]$rate
NULL



$probs
$probs[[1]]
[1] 0.5

$probs[[2]]
[1] 0.5


> 
> ## ------------------------------------------------
> ## Method `Distribution$get_param_bounds`
> ## ------------------------------------------------
> 
> dist_mixture(
+   list(dist_dirac(), dist_exponential()),
+   probs = list(0.5, 0.5)
+ )$get_param_bounds()
$dists
$dists[[1]]
$dists[[1]]$point
(-Inf, Inf)


$dists[[2]]
$dists[[2]]$rate
(0, Inf)



$probs
list()

> 
> dist_mixture(
+   list(dist_dirac(), dist_exponential())
+ )$get_param_bounds()
$dists
$dists[[1]]
$dists[[1]]$point
(-Inf, Inf)


$dists[[2]]
$dists[[2]]$rate
(0, Inf)



$probs
$probs[[1]]
[0, 1]

$probs[[2]]
[0, 1]


> 
> dist_genpareto()$get_param_bounds()
$u
(-Inf, Inf)

$sigmau
(0, Inf)

$xi
(-Inf, Inf)

> dist_genpareto1()$get_param_bounds()
$u
(-Inf, Inf)

$sigmau
(0, Inf)

$xi
[0, 1]

> 
> ## ------------------------------------------------
> ## Method `Distribution$get_param_constraints`
> ## ------------------------------------------------
> 
> dist_mixture(
+   list(dist_dirac(), dist_exponential())
+ )$get_param_constraints()
function (params) 
{
    prob_mat <- do.call(cbind, params$probs)
    nms <- names(flatten_params(params))
    jac_full <- matrix(0, nrow = nrow(prob_mat), ncol = length(nms))
    jac_full[, grepl("^probs", nms)] <- 1
    list(constraints = rowSums(prob_mat) - 1, jacobian = jac_full)
}
<environment: 0x117d911c8>
> 
> ## ------------------------------------------------
> ## Method `Distribution$export_functions`
> ## ------------------------------------------------
> 
> tmp_env <- new.env(parent = globalenv())
> dist_exponential()$export_functions(
+   name = "exp",
+   envir = tmp_env,
+   with_params = list(rate = 2.0)
+ )
Exported `dexp()`.
Exported `rexp()`.
Exported `pexp()`.
Exported `qexp()`.
> evalq(
+   fitdistrplus::fitdist(rexp(100), "exp"),
+   envir = tmp_env
+ )
Fitting of the distribution ' exp ' by maximum likelihood 
Parameters:
     estimate Std. Error
rate 2.142262  0.2142262
> 
> 
> 
> cleanEx()
> nameEx("GenPareto")
> ### * GenPareto
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: GenPareto
> ### Title: The Generalized Pareto Distribution (GPD)
> ### Aliases: GenPareto rgpd dgpd pgpd qgpd
> 
> ### ** Examples
> 
> 
> x <- rgpd(1000, u = 1, sigmau = 0.5, xi = 0.1)
> xx <- seq(-1, 10, 0.01)
> hist(x, breaks = 100, freq = FALSE, xlim = c(-1, 10))
> lines(xx, dgpd(xx, u = 1, sigmau = 0.5, xi = 0.1))
> 
> plot(xx, dgpd(xx, u = 1, sigmau = 1, xi = 0), type = "l")
> lines(xx, dgpd(xx, u = 0.5, sigmau = 1, xi = -0.3), col = "blue", lwd = 2)
> lines(xx, dgpd(xx, u = 1.5, sigmau = 1, xi = 0.3), col = "red", lwd = 2)
> 
> plot(xx, dgpd(xx, u = 1, sigmau = 1, xi = 0), type = "l")
> lines(xx, dgpd(xx, u = 1, sigmau = 0.5, xi = 0), col = "blue", lwd = 2)
> lines(xx, dgpd(xx, u = 1, sigmau = 2, xi = 0), col = "red", lwd = 2)
> 
> 
> 
> 
> cleanEx()
> nameEx("Pareto")
> ### * Pareto
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Pareto
> ### Title: The Pareto Distribution
> ### Aliases: Pareto rpareto dpareto ppareto qpareto
> 
> ### ** Examples
> 
> 
> x <- rpareto(1000, shape = 10, scale = 5)
> xx <- seq(-1, 10, 0.01)
> hist(x, breaks = 100, freq = FALSE, xlim = c(-1, 10))
> lines(xx, dpareto(xx, shape = 10, scale = 5))
> 
> plot(xx, dpareto(xx, shape = 10, scale = 5), type = "l")
> lines(xx, dpareto(xx, shape = 3, scale = 5), col = "red", lwd = 2)
> 
> plot(xx, dpareto(xx, shape = 10, scale = 10), type = "l")
> lines(xx, dpareto(xx, shape = 10, scale = 5), col = "blue", lwd = 2)
> lines(xx, dpareto(xx, shape = 10, scale = 20), col = "red", lwd = 2)
> 
> 
> 
> 
> cleanEx()
> nameEx("as_params")
> ### * as_params
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_params
> ### Title: Convert TensorFlow tensors to distribution parameters
> ###   recursively
> ### Aliases: as_params
> 
> ### ** Examples
> 
> if (interactive() && keras::is_keras_available()) {
+   tf_params <- list(
+     probs = k_matrix(t(c(0.5, 0.3, 0.2))),
+     shapes = k_matrix(t(c(1L, 2L, 3L)), dtype = "int32"),
+     scale = keras::k_constant(1.0)
+   )
+   params <- as_params(tf_params)
+   dist <- dist_erlangmix(vector("list", 3L))
+   dist$sample(10L, with_params = params)
+ }
> 
> 
> 
> 
> cleanEx()
> nameEx("blended_transition")
> ### * blended_transition
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: blended_transition
> ### Title: Transition functions for blended distributions
> ### Aliases: blended_transition blended_transition_inv
> 
> ### ** Examples
> 
> library(ggplot2)
> xx <- seq(from = 0, to = 20, length.out = 101)
> blend_mat <- blended_transition(xx, u = 10, eps = 3, .gradient = TRUE)
> ggplot(
+   data.frame(
+     x = rep(xx, 2L),
+     fun = rep(c("p", "q"), each = length(xx)),
+     y = as.numeric(blend_mat),
+     relevant = c(xx <= 13, xx >= 7)
+   ),
+   aes(x = x, y = y, color = fun, linetype = relevant)
+ ) %+%
+   geom_line() %+%
+   theme_bw() %+%
+   theme(
+     legend.position = "bottom", legend.box = "horizontal"
+   ) %+%
+   guides(color = guide_legend(direction = "horizontal", title = ""), linetype = guide_none()) %+%
+   scale_linetype_manual(values = c("TRUE" = 1, "FALSE" = 3))
> 
> ggplot(
+   data.frame(
+     x = rep(xx, 2L),
+     fun = rep(c("p'", "q'"), each = length(xx)),
+     y = as.numeric(attr(blend_mat, "gradient")),
+     relevant = c(xx <= 13, xx >= 7)
+   ),
+   aes(x = x, y = y, color = fun, linetype = relevant)
+ ) %+%
+   geom_line() %+%
+   theme_bw() %+%
+   theme(
+     legend.position = "bottom", legend.box = "horizontal"
+   ) %+%
+   guides(color = guide_legend(direction = "horizontal", title = ""), linetype = guide_none()) %+%
+   scale_linetype_manual(values = c("TRUE" = 1, "FALSE" = 3))
> 
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’

> nameEx("callback_adaptive_lr")
> ### * callback_adaptive_lr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: callback_adaptive_lr
> ### Title: Keras Callback for adaptive learning rate with weight
> ###   restoration
> ### Aliases: callback_adaptive_lr
> 
> ### ** Examples
> 
> dist <- dist_exponential()
> group <- sample(c(0, 1), size = 100, replace = TRUE)
> x <- dist$sample(100, with_params = list(rate = group + 1))
> global_fit <- fit(dist, x)
> 
> if (interactive() && keras::is_keras_available()) {
+   library(keras)
+   l_in <- layer_input(shape = 1L)
+   mod <- tf_compile_model(
+     inputs = list(l_in),
+     intermediate_output = l_in,
+     dist = dist,
+     optimizer = optimizer_adam(),
+     censoring = FALSE,
+     truncation = FALSE
+   )
+   tf_initialise_model(mod, global_fit$params)
+   fit_history <- fit(
+     mod,
+     x = k_constant(group),
+     y = as_trunc_obs(x),
+     epochs = 20L,
+     callbacks = list(
+       callback_adaptive_lr("loss", factor = 0.5, patience = 2L, verbose = 1L, min_lr = 1.0e-4),
+       callback_reduce_lr_on_plateau("loss", min_lr = 1.0) # to track lr
+     )
+   )
+ 
+   plot(fit_history)
+ 
+   predicted_means <- predict(mod, data = k_constant(c(0, 1)))
+ }
> 
> 
> 
> 
> cleanEx()
> nameEx("callback_debug_dist_gradients")
> ### * callback_debug_dist_gradients
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: callback_debug_dist_gradients
> ### Title: Callback to monitor likelihood gradient components
> ### Aliases: callback_debug_dist_gradients
> 
> ### ** Examples
> 
> dist <- dist_exponential()
> group <- sample(c(0, 1), size = 100, replace = TRUE)
> x <- dist$sample(100, with_params = list(rate = group + 1))
> global_fit <- fit(dist, x)
> 
> if (interactive() && keras::is_keras_available()) {
+   library(keras)
+   l_in <- layer_input(shape = 1L)
+   mod <- tf_compile_model(
+     inputs = list(l_in),
+     intermediate_output = l_in,
+     dist = dist,
+     optimizer = optimizer_adam(),
+     censoring = FALSE,
+     truncation = FALSE
+   )
+   tf_initialise_model(mod, global_fit$params)
+   # TODO update when rstudio/keras#1230 is fixed
+   gradient_tracker <- callback_debug_dist_gradients(mod, k_constant(group), x, keep_grads = TRUE)
+   fit_history <- fit(
+     mod,
+     x = k_constant(group),
+     y = x,
+     epochs = 20L,
+     callbacks = list(
+       callback_adaptive_lr("loss", factor = 0.5, patience = 2L, verbose = 1L, min_lr = 1.0e-4),
+       gradient_tracker,
+       callback_reduce_lr_on_plateau("loss", min_lr = 1.0) # to track lr
+     )
+   )
+   gradient_tracker$gradient_logs[[20]]$dens
+ 
+   plot(fit_history)
+ 
+   predicted_means <- predict(mod, data = k_constant(c(0, 1)))
+ }
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_bdegp")
> ### * dist_bdegp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_bdegp
> ### Title: Construct a BDEGP-Family
> ### Aliases: dist_bdegp
> 
> ### ** Examples
> 
> dist <- dist_bdegp(n = 1, m = 2, u = 10, epsilon = 3)
> params <- list(
+   dists = list(
+     list(),
+     list(
+       dists = list(
+         list(
+           dist = list(
+             shapes = list(1L, 2L),
+             scale = 1.0,
+             probs = list(0.7, 0.3)
+           )
+         ),
+         list(
+           sigmau = 1.0,
+           xi = 0.1
+         )
+       ),
+       probs = list(0.1, 0.9)
+     )
+   ),
+   probs = list(0.95, 0.05)
+ )
> x <- dist$sample(100, with_params = params)
> 
> plot_distributions(
+   theoretical = dist,
+   empirical = dist_empirical(x),
+   .x = seq(0, 20, length.out = 101),
+   with_params = list(theoretical = params)
+ )
Warning: Removed 9 rows containing missing values (`geom_line()`).
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_beta")
> ### * dist_beta
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_beta
> ### Title: Beta Distribution
> ### Aliases: dist_beta
> 
> ### ** Examples
> 
> d_beta <- dist_beta(shape1 = 2, shape2 = 2, ncp = 0)
> x <- d_beta$sample(100)
> d_emp <- dist_empirical(x)
> 
> plot_distributions(
+   empirical = d_emp,
+   theoretical = d_beta,
+   estimated = d_beta,
+   with_params = list(
+     estimated = inflate_params(
+       fitdistrplus::fitdist(x, distr = "beta")$estimate
+     )
+   ),
+   .x = seq(0, 2, length.out = 100)
+ )
Warning: Removed 140 rows containing missing values (`geom_line()`).
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_binomial")
> ### * dist_binomial
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_binomial
> ### Title: Binomial Distribution
> ### Aliases: dist_binomial
> 
> ### ** Examples
> 
> d_binom <- dist_binomial(size = 10, prob = 0.5)
> x <- d_binom$sample(100)
> d_emp <- dist_empirical(x)
> 
> plot_distributions(
+   empirical = d_emp,
+   theoretical = d_binom,
+   estimated = d_binom,
+   with_params = list(
+     estimated = list(
+       size = max(x),
+       prob = mean(x) / max(x)
+     )
+   ),
+   .x = 0:max(x)
+ )
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_blended")
> ### * dist_blended
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_blended
> ### Title: Blended distribution
> ### Aliases: dist_blended
> 
> ### ** Examples
> 
> bd <- dist_blended(
+   list(
+     dist_normal(mean = 0.0, sd = 1.0),
+     dist_genpareto(u = 3.0, sigmau = 1.0, xi = 3.0)
+   ),
+   breaks = list(3.0),
+   bandwidths = list(0.5),
+   probs = list(0.9, 0.1)
+ )
> 
> plot_distributions(
+   bd,
+   .x = seq(-3, 10, length.out = 100),
+   plots = c("d", "p")
+ )
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_dirac")
> ### * dist_dirac
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_dirac
> ### Title: Dirac (degenerate point) Distribution
> ### Aliases: dist_dirac
> 
> ### ** Examples
> 
> d_dirac <- dist_dirac(1.5)
> d_dirac$sample(2L)
[1] 1.5 1.5
> d_dirac$sample(2L, list(point = 42.0))
[1] 42 42
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_discrete")
> ### * dist_discrete
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_discrete
> ### Title: Discrete Distribution
> ### Aliases: dist_discrete
> 
> ### ** Examples
> 
> d_discrete <- dist_discrete(probs = list(0.5, 0.25, 0.15, 0.1))
> x <- d_discrete$sample(100)
> d_emp <- dist_empirical(x)
> 
> plot_distributions(
+   empirical = d_emp,
+   theoretical = d_discrete,
+   estimated = d_discrete,
+   with_params = list(
+     estimated = list(
+       size = max(x),
+       probs = as.list(unname(table(x)) / 100)
+     )
+   ),
+   .x = 0:max(x)
+ )
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_empirical")
> ### * dist_empirical
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_empirical
> ### Title: Empirical distribution
> ### Aliases: dist_empirical
> 
> ### ** Examples
> 
> x <- rexp(20, rate = 1)
> dx <- dist_empirical(sample = x, positive = TRUE)
> 
> y <- rnorm(20)
> dy <- dist_empirical(sample = y)
> 
> plot_distributions(
+   exponential = dx,
+   normal = dy,
+   .x = seq(-3, 3, length.out = 100)
+ )
Warning: Removed 11 rows containing missing values (`geom_line()`).
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_erlangmix")
> ### * dist_erlangmix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_erlangmix
> ### Title: Erlang Mixture distribution
> ### Aliases: dist_erlangmix
> 
> ### ** Examples
> 
> params <- list(scale = 1.0, probs = list(0.5, 0.3, 0.2), shapes = list(1L, 2L, 3L))
> dist <- dist_erlangmix(vector("list", 3L))
> x <- dist$sample(20, with_params = params)
> d_emp <- dist_empirical(x, positive = TRUE)
> 
> plot_distributions(
+   empirical = d_emp,
+   theoretical = dist,
+   with_params = list(
+     theoretical = params
+   ),
+   .x = seq(1e-4, 5, length.out = 100)
+ )
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_exponential")
> ### * dist_exponential
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_exponential
> ### Title: Exponential distribution
> ### Aliases: dist_exponential
> 
> ### ** Examples
> 
> rate <- 1
> d_exp <- dist_exponential()
> x <- d_exp$sample(20, with_params = list(rate = rate))
> d_emp <- dist_empirical(x, positive = TRUE)
> 
> plot_distributions(
+   empirical = d_emp,
+   theoretical = d_exp,
+   estimated = d_exp,
+   with_params = list(
+     theoretical = list(rate = rate),
+     estimated = list(rate = 1 / mean(x))
+   ),
+   .x = seq(1e-4, 5, length.out = 100)
+ )
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_gamma")
> ### * dist_gamma
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_gamma
> ### Title: Gamma distribution
> ### Aliases: dist_gamma
> 
> ### ** Examples
> 
> alpha <- 2
> beta <- 2
> 
> d_gamma <- dist_gamma(shape = alpha, rate = beta)
> x <- d_gamma$sample(100)
> d_emp <- dist_empirical(x, positive = TRUE)
> 
> plot_distributions(
+   empirical = d_emp,
+   theoretical = d_gamma,
+   estimated = d_gamma,
+   with_params = list(
+     estimated = inflate_params(
+       fitdistrplus::fitdist(x, distr = "gamma")$estimate
+     )
+   ),
+   .x = seq(1e-3, max(x), length.out = 100)
+ )
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_genpareto")
> ### * dist_genpareto
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_genpareto
> ### Title: Generalized Pareto Distribution
> ### Aliases: dist_genpareto dist_genpareto1
> 
> ### ** Examples
> 
> d_genpareto <- dist_genpareto(u = 0, sigmau = 1, xi = 1)
> x <- d_genpareto$sample(100)
> d_emp <- dist_empirical(x)
> 
> d_genpareto$export_functions("gpd") # so fitdistrplus finds it
Exported `dgpd()`.
Exported `rgpd()`.
Exported `pgpd()`.
Exported `qgpd()`.
> 
> plot_distributions(
+   empirical = d_emp,
+   theoretical = d_genpareto,
+   estimated = d_genpareto,
+   with_params = list(
+     estimated = fit(dist_genpareto(), x)$params
+   ),
+   .x = seq(0, 5, length.out = 100)
+ )
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_lognormal")
> ### * dist_lognormal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_lognormal
> ### Title: Log Normal distribution
> ### Aliases: dist_lognormal
> 
> ### ** Examples
> 
> mu <- 0
> sigma <- 1
> 
> d_lnorm <- dist_lognormal(meanlog = mu, sdlog = sigma)
> x <- d_lnorm$sample(20)
> d_emp <- dist_empirical(x, positive = TRUE)
> 
> plot_distributions(
+   empirical = d_emp,
+   theoretical = d_lnorm,
+   estimated = d_lnorm,
+   with_params = list(
+     estimated = inflate_params(
+       fitdistrplus::fitdist(x, distr = "lnorm")$estimate
+     )
+   ),
+   .x = seq(1e-3, 5, length.out = 100)
+ )
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_mixture")
> ### * dist_mixture
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_mixture
> ### Title: Mixture distribution
> ### Aliases: dist_mixture
> 
> ### ** Examples
> 
> 
> # A complicated way to define a uniform distribution on \[0, 2\]
> dist_mixture(
+   dists = list(
+     dist_uniform(min = 0, max = 1),
+     dist_uniform(min = 1, max = 2)
+   ),
+   probs = list(0.5, 0.5)
+ )
A Mixture<UniformDistribution, UniformDistribution> with 0 dof
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_negbinomial")
> ### * dist_negbinomial
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_negbinomial
> ### Title: Negative binomial Distribution
> ### Aliases: dist_negbinomial
> 
> ### ** Examples
> 
> d_nbinom <- dist_negbinomial(size = 3.5, mu = 8.75)
> x <- d_nbinom$sample(100)
> d_emp <- dist_empirical(x)
> 
> plot_distributions(
+   empirical = d_emp,
+   theoretical = d_nbinom,
+   estimated = d_nbinom,
+   with_params = list(
+     estimated = inflate_params(
+       fitdistrplus::fitdist(x, distr = "nbinom")$estimate
+     )
+   ),
+   .x = 0:max(x)
+ )
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_normal")
> ### * dist_normal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_normal
> ### Title: Normal distribution
> ### Aliases: dist_normal
> 
> ### ** Examples
> 
> mu <- 0
> sigma <- 1
> 
> d_norm <- dist_normal(mean = mu, sd = sigma)
> x <- d_norm$sample(20)
> d_emp <- dist_empirical(x)
> 
> plot_distributions(
+   empirical = d_emp,
+   theoretical = d_norm,
+   estimated = d_norm,
+   with_params = list(
+     estimated = list(mean = mean(x), sd = sd(x))
+   ),
+   .x = seq(-3, 3, length.out = 100)
+ )
Warning: Removed 3 rows containing missing values (`geom_line()`).
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_pareto")
> ### * dist_pareto
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_pareto
> ### Title: Pareto Distribution
> ### Aliases: dist_pareto
> 
> ### ** Examples
> 
> d_pareto <- dist_pareto(shape = 3, scale = 1)
> x <- d_pareto$sample(100)
> d_emp <- dist_empirical(x)
> 
> plot_distributions(
+   empirical = d_emp,
+   theoretical = d_pareto,
+   estimated = d_pareto,
+   with_params = list(
+     estimated = inflate_params(
+       fitdistrplus::fitdist(x, distr = "pareto")$estimate
+     )
+   ),
+   .x = seq(0, 2, length.out = 100)
+ )
Warning in fitdistrplus::fitdist(x, distr = "pareto") :
  The dpareto function should return a vector of with NaN values when input has inconsistent values and not raise an error
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_poisson")
> ### * dist_poisson
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_poisson
> ### Title: Poisson Distribution
> ### Aliases: dist_poisson
> 
> ### ** Examples
> 
> d_pois <- dist_poisson(lambda = 5.0)
> x <- d_pois$sample(100)
> d_emp <- dist_empirical(x)
> 
> plot_distributions(
+   empirical = d_emp,
+   theoretical = d_pois,
+   estimated = d_pois,
+   with_params = list(
+     estimated = inflate_params(
+       fitdistrplus::fitdist(x, distr = "pois")$estimate
+     )
+   ),
+   .x = 0:max(x)
+ )
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_translate")
> ### * dist_translate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_translate
> ### Title: Tranlsated distribution
> ### Aliases: dist_translate
> 
> ### ** Examples
> 
> d_norm <- dist_normal(mean = 0, sd = 1)
> d_tnorm <- dist_translate(dist = d_norm, offset = 1)
> plot_distributions(d_norm, d_tnorm, .x = seq(-2, 3, length.out = 100))
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_trunc")
> ### * dist_trunc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_trunc
> ### Title: Truncated distribution
> ### Aliases: dist_trunc
> 
> ### ** Examples
> 
> d_norm <- dist_normal(mean = 0, sd = 1)
> d_tnorm <- dist_trunc(dist = d_norm, min = -2, max = 2, offset = 1)
> plot_distributions(d_norm, d_tnorm, .x = seq(-2, 3, length.out = 100))
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_uniform")
> ### * dist_uniform
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_uniform
> ### Title: Uniform distribution
> ### Aliases: dist_uniform
> 
> ### ** Examples
> 
> d_unif <- dist_uniform(min = 0, max = 1)
> x <- d_unif$sample(100)
> d_emp <- dist_empirical(x)
> 
> plot_distributions(
+   empirical = d_emp,
+   theoretical = d_unif,
+   estimated = d_unif,
+   with_params = list(
+     estimated = inflate_params(
+       fitdistrplus::fitdist(x, distr = "unif")$estimate
+     )
+   ),
+   .x = seq(0, 1, length.out = 100)
+ )
Warning: Removed 1 row containing missing values (`geom_line()`).
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_weibull")
> ### * dist_weibull
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_weibull
> ### Title: Weibull Distribution
> ### Aliases: dist_weibull
> 
> ### ** Examples
> 
> d_weibull <- dist_weibull(shape = 3, scale = 1)
> x <- d_weibull$sample(100)
> d_emp <- dist_empirical(x)
> 
> plot_distributions(
+   empirical = d_emp,
+   theoretical = d_weibull,
+   estimated = d_weibull,
+   with_params = list(
+     estimated = inflate_params(
+       fitdistrplus::fitdist(x, distr = "weibull")$estimate
+     )
+   ),
+   .x = seq(0, 2, length.out = 100)
+ )
Warning: Removed 4 rows containing missing values (`geom_line()`).
> 
> 
> 
> 
> cleanEx()
> nameEx("fit.reservr_keras_model")
> ### * fit.reservr_keras_model
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fit.reservr_keras_model
> ### Title: Fit a neural network based distribution model to data
> ### Aliases: fit.reservr_keras_model
> 
> ### ** Examples
> 
> dist <- dist_exponential()
> params <- list(rate = 1.0)
> N <- 100L
> rand_input <- runif(N)
> x <- dist$sample(N, with_params = params)
> 
> if (interactive() && keras::is_keras_available()) {
+   tf_in <- keras::layer_input(1L)
+   mod <- tf_compile_model(
+     inputs = list(tf_in),
+     intermediate_output = tf_in,
+     dist = dist,
+     optimizer = keras::optimizer_adam(),
+     censoring = FALSE,
+     truncation = FALSE
+   )
+ 
+   tf_fit <- fit(
+     object = mod,
+     x = k_matrix(rand_input),
+     y = x,
+     epochs = 10L,
+     callbacks = list(
+       callback_debug_dist_gradients(mod, k_matrix(rand_input), x, keep_grads = TRUE)
+     )
+   )
+ }
> 
> 
> 
> 
> cleanEx()
> nameEx("fit_blended")
> ### * fit_blended
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fit_blended
> ### Title: Fit a Blended mixture using an ECME-Algorithm
> ### Aliases: fit_blended
> 
> ### ** Examples
> 
> dist <- dist_blended(
+    list(
+      dist_exponential(),
+      dist_genpareto()
+    )
+  )
> 
> params <- list(
+   probs = list(0.9, 0.1),
+   dists = list(
+     list(rate = 2.0),
+     list(u = 1.5, xi = 0.2, sigmau = 1.0)
+   ),
+   breaks = list(1.5),
+   bandwidths = list(0.3)
+ )
> 
> x <- dist$sample(100L, with_params = params)
> 
> dist$default_params$breaks <- params$breaks
> dist$default_params$bandwidths <- params$bandwidths
> if (interactive()) {
+   fit_blended(dist, x)
+ }
> 
> 
> 
> 
> cleanEx()
> nameEx("fit_dist")
> ### * fit_dist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fit_dist
> ### Title: Fit a general distribution to observations
> ### Aliases: fit_dist fit_dist_direct fit.Distribution
> 
> ### ** Examples
> 
> x <- rexp(100)
> lambda_hat <- 1 / mean(x)
> lambda_hat2 <- fit_dist(dist_exponential(), x)$params$rate
> identical(lambda_hat, lambda_hat2)
[1] FALSE
> dist <- dist_mixture(list(dist_normal(), dist_translate(dist_exponential(), offset = 6)))
> params <- list(
+   dists = list(list(mean = 5, sd = 1), list(dist = list(rate = 1))), probs = list(0.95, 0.05)
+ )
> set.seed(2000)
> u <- runif(100, 10, 20)
> x <- dist$sample(100, with_params = params)
> obs <- trunc_obs(x = x[x <= u], tmin = -Inf, tmax = u[x <= u])
> 
> default_fit <- fit_dist(dist, obs)
> direct_fit <- fit_dist_direct(dist, obs)
> # NB: direct optimisation steps with pre-run take a few seconds
> 
> 
> 
> 
> cleanEx()
> nameEx("fit_dist_start")
> ### * fit_dist_start
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fit_dist_start.MixtureDistribution
> ### Title: Find starting values for distribution parameters
> ### Aliases: fit_dist_start.MixtureDistribution fit_dist_start
> 
> ### ** Examples
> 
> fit_dist_start(dist_exponential(), rexp(100))
$rate
[1] 0.9702366

> 
> 
> 
> cleanEx()
> nameEx("fit_erlang_mixture")
> ### * fit_erlang_mixture
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fit_erlang_mixture
> ### Title: Fit an Erlang mixture using an ECME-Algorithm
> ### Aliases: fit_erlang_mixture
> 
> ### ** Examples
> 
> dist <- dist_erlangmix(list(NULL, NULL, NULL))
> params <- list(
+   shapes = list(1L, 4L, 12L),
+   scale = 2.0,
+   probs = list(0.5, 0.3, 0.2)
+ )
> x <- dist$sample(100L, with_params = params)
> fit_erlang_mixture(dist, x, init = "kmeans")
$params
$params$probs
$params$probs[[1]]
[1] 0.43

$params$probs[[2]]
[1] 0.36

$params$probs[[3]]
[1] 0.21


$params$shapes
$params$shapes[[1]]
[1] 1

$params$shapes[[2]]
[1] 5

$params$shapes[[3]]
[1] 15


$params$scale
[1] 1.47091


$params_hist
list()

$iter
[1] 1

$logLik
'log Lik.' -290.9368 (df=6)

> 
> 
> 
> 
> cleanEx()
> nameEx("fit_mixture")
> ### * fit_mixture
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fit_mixture
> ### Title: Fit a generic mixture using an ECME-Algorithm
> ### Aliases: fit_mixture
> 
> ### ** Examples
> 
> dist <- dist_mixture(
+   list(
+     dist_dirac(0.0),
+     dist_exponential()
+   )
+ )
> 
> params <- list(
+   probs = list(0.1, 0.9),
+   dists = list(
+     list(),
+     list(rate = 1.0)
+   )
+ )
> 
> x <- dist$sample(100L, with_params = params)
> 
> fit_mixture(dist, x)
$params
$params$dists
$params$dists[[1]]
list()

$params$dists[[2]]
$params$dists[[2]]$rate
[1] 1.028293



$params$probs
$params$probs[[1]]
[1] 0.07

$params$probs[[2]]
[1] 0.93



$iter
[1] 1

$logLik
'log Lik.' -115.7692 (df=2)

> 
> 
> 
> 
> cleanEx()
> nameEx("flatten_params")
> ### * flatten_params
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: flatten_params
> ### Title: Flatten / Inflate parameter lists / vectors
> ### Aliases: flatten_params flatten_params_matrix flatten_bounds
> ###   inflate_params
> 
> ### ** Examples
> 
> library(ggplot2)
> 
> mm <- dist_mixture(list(
+   dist_exponential(NULL),
+   dist_lognormal(0.5, NULL)
+ ), list(NULL, 1))
> 
> ph <- mm$get_placeholders()
> ph_flat <- flatten_params(ph)
> ph_reinflated <- inflate_params(ph_flat)
> ph_flat[] <- c(1, 1, 6)
> ph_sample <- inflate_params(ph_flat)
> 
> x <- mm$sample(
+   100,
+   with_params = ph_sample
+ )
> 
> emp_cdf <- ecdf(x)
> 
> ggplot(data.frame(t = seq(from = min(x), to = max(x), length.out = 100))) %+%
+   geom_point(aes(x = t, y = emp_cdf(t))) %+%
+   geom_line(aes(x = t, y = mm$probability(t, with_params = ph_sample)),
+             linetype = 2)
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’

> nameEx("integrate_gk")
> ### * integrate_gk
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: integrate_gk
> ### Title: Adaptive Gauss-Kronrod Quadrature for multiple limits
> ### Aliases: integrate_gk
> 
> ### ** Examples
> 
> # Argument recycling and parallel integration of two intervals
> integrate_gk(sin, 0, c(pi, 2 * pi))
[1]  2.000000e+00 -3.141135e-16
> 
> dist <- dist_exponential()
> integrate_gk(
+   function(x, p) dist$density(x, with_params = p),
+   lower = 0, upper = 1:10,
+   params = list(rate = 1 / 1:10)
+ )
 [1] 0.6321206 0.6321206 0.6321206 0.6321206 0.6321206 0.6321206 0.6321206
 [8] 0.6321206 0.6321206 0.6321206
> dist$probability(1:10, with_params = list(rate = 1 / 1:10))
 [1] 0.6321206 0.6321206 0.6321206 0.6321206 0.6321206 0.6321206 0.6321206
 [8] 0.6321206 0.6321206 0.6321206
> 
> 
> 
> 
> cleanEx()
> nameEx("interval-operations")
> ### * interval-operations
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interval-operations
> ### Title: Convex union and intersection of intervals
> ### Aliases: interval-operations interval_union interval_intersection
> 
> ### ** Examples
> 
> interval_union(
+   interval(c(0, 1), closed = TRUE),
+   interval(c(1, 2))
+ )
[0, 2)
> 
> interval_union(
+   interval(c(0, 5)),
+   interval(c(1, 4), closed = TRUE)
+ )
(0, 5)
> 
> # Convex union is not equal to set union:
> interval_union(
+   interval(c(0, 1)),
+   interval(c(2, 3))
+ )
(0, 3)
> 
> # The empty union is {}
> interval_union()
{}
> 
> interval_intersection(
+   interval(c(0, 1)),
+   interval(c(0.5, 2))
+ )
(0.5, 1)
> 
> interval_intersection(
+   interval(c(0, Inf)),
+   interval(c(-Inf, 0))
+ )
{}
> 
> interval_intersection(
+   interval(c(0, Inf), include_lowest = TRUE),
+   interval(c(-Inf, 0), include_highest = TRUE)
+ )
{0}
> 
> interval_intersection(
+   interval(c(0, 5)),
+   interval(c(1, 6), closed = TRUE)
+ )
[1, 5)
> 
> # The empty intersection is (-Inf, Inf)
> interval_intersection()
(-Inf, Inf)
> 
> 
> 
> cleanEx()
> nameEx("interval")
> ### * interval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interval
> ### Title: Intervals
> ### Aliases: interval is.Interval
> 
> ### ** Examples
> 
> # The real line
> interval()
(-Inf, Inf)
> 
> # Closed unit interval
> interval(c(0, 1), closed = TRUE)
[0, 1]
> # Alternative form
> interval(0, 1, closed = TRUE)
[0, 1]
> 
> # Non-negative real line
> interval(c(0, Inf), include_lowest = TRUE)
[0, Inf)
> 
> 
> 
> cleanEx()
> nameEx("is.Distribution")
> ### * is.Distribution
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.Distribution
> ### Title: Test if object is a Distribution
> ### Aliases: is.Distribution
> 
> ### ** Examples
> 
> is.Distribution(dist_dirac())
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("k_matrix")
> ### * k_matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: k_matrix
> ### Title: Cast to a TensorFlow matrix
> ### Aliases: k_matrix
> 
> ### ** Examples
> 
> if (interactive() && keras::is_keras_available()) {
+   k_matrix(diag(1:3))
+   k_matrix(diag(1:3), dtype = "int32")
+   # Vectors are converted to columns:
+   k_matrix(1:3)
+ }
> 
> 
> 
> 
> cleanEx()
> nameEx("plot_distributions")
> ### * plot_distributions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_distributions
> ### Title: Plot several distributions
> ### Aliases: plot_distributions
> 
> ### ** Examples
> 
> rate <- 1
> x <- rexp(20, rate)
> d_emp <- dist_empirical(x, positive = TRUE)
> d_exp <- dist_exponential()
> plot_distributions(
+   empirical = d_emp,
+   theoretical = d_exp,
+   estimated = d_exp,
+   with_params = list(
+     theoretical = list(rate = rate),
+     estimated = list(rate = 1 / mean(x))
+   ),
+   .x = seq(1e-4, 5, length.out = 100)
+ )
> 
> 
> 
> cleanEx()
> nameEx("predict.reservr_keras_model")
> ### * predict.reservr_keras_model
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predict.reservr_keras_model
> ### Title: Predict individual distribution parameters
> ### Aliases: predict.reservr_keras_model
> 
> ### ** Examples
> 
> if (interactive() && keras::is_keras_available()) {
+   dist <- dist_exponential()
+   params <- list(rate = 1.0)
+   N <- 100L
+   rand_input <- runif(N)
+   x <- dist$sample(N, with_params = params)
+ 
+   tf_in <- keras::layer_input(1L)
+   mod <- tf_compile_model(
+     inputs = list(tf_in),
+     intermediate_output = tf_in,
+     dist = dist,
+     optimizer = keras::optimizer_adam(),
+     censoring = FALSE,
+     truncation = FALSE
+   )
+ 
+   tf_fit <- fit(
+     object = mod,
+     x = k_matrix(rand_input),
+     y = x,
+     epochs = 10L,
+     callbacks = list(
+       callback_debug_dist_gradients(mod, k_matrix(rand_input), x)
+     )
+   )
+ 
+   tf_preds <- predict(mod, data = k_matrix(rand_input))
+ }
> 
> 
> 
> 
> cleanEx()
> nameEx("prob_report")
> ### * prob_report
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prob_report
> ### Title: Determine probability of reporting under a Poisson arrival
> ###   Process
> ### Aliases: prob_report
> 
> ### ** Examples
> 
> dist <- dist_exponential()
> ints <- data.frame(
+   xmin = 0,
+   xmax = 1,
+   tmin = seq_len(10) - 1.0,
+   tmax = seq_len(10)
+ )
> params <- list(rate = rep(c(1, 0.5), each = 5))
> 
> prob_report(dist, ints, with_params = params)
 [1] 0.367879441 0.399576401 0.146995943 0.054076785 0.019893738 0.041904709
 [7] 0.025416491 0.015415881 0.009350204 0.005671186
> 
> 
> 
> 
> cleanEx()
> nameEx("quantile.Distribution")
> ### * quantile.Distribution
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quantile.Distribution
> ### Title: Quantiles of Distributions
> ### Aliases: quantile.Distribution
> 
> ### ** Examples
> 
> # With quantiles available
> dist <- dist_normal(sd = 1)
> qqs <- quantile(dist, probs = rep(0.5, 3), with_params = list(mean = 1:3))
> stopifnot(all.equal(qqs, 1:3))
> 
> # Without quantiles available
> dist <- dist_erlangmix(shapes = list(1, 2, 3), scale = 1.0)
> my_probs <- c(0, 0.01, 0.25, 0.5, 0.75, 1)
> qqs <- quantile(
+   dist, probs = my_probs,
+   with_params = list(probs = list(0.5, 0.3, 0.2)), .start = 2
+ )
> 
> all.equal(dist$probability(qqs, with_params = list(probs = list(0.5, 0.3, 0.2))), my_probs)
[1] "Mean relative difference: 2.890015e-06"
> # Careful: Numerical estimation of extreme quantiles can result in out-of-bounds values.
> # The correct 0-quantile would be 0 in this case, but it was estimated < 0.
> qqs[1L]
[1] -1.138089
> 
> 
> 
> 
> cleanEx()
> nameEx("softmax")
> ### * softmax
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: softmax
> ### Title: Soft-Max function
> ### Aliases: softmax dsoftmax
> 
> ### ** Examples
> 
> softmax(c(5, 5))
[1] 0.5 0.5
> softmax(diag(nrow = 5, ncol = 6))
          [,1]      [,2]      [,3]      [,4]      [,5]      [,6]
[1,] 0.3521874 0.1295625 0.1295625 0.1295625 0.1295625 0.1295625
[2,] 0.1295625 0.3521874 0.1295625 0.1295625 0.1295625 0.1295625
[3,] 0.1295625 0.1295625 0.3521874 0.1295625 0.1295625 0.1295625
[4,] 0.1295625 0.1295625 0.1295625 0.3521874 0.1295625 0.1295625
[5,] 0.1295625 0.1295625 0.1295625 0.1295625 0.3521874 0.1295625
> 
> 
> 
> cleanEx()
> nameEx("tf_compile_model")
> ### * tf_compile_model
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tf_compile_model
> ### Title: Compile a Keras model for truncated data under dist
> ### Aliases: tf_compile_model
> 
> ### ** Examples
> 
> dist <- dist_exponential()
> params <- list(rate = 1.0)
> N <- 100L
> rand_input <- runif(N)
> x <- dist$sample(N, with_params = params)
> 
> if (interactive() && keras::is_keras_available()) {
+   tf_in <- keras::layer_input(1L)
+   mod <- tf_compile_model(
+     inputs = list(tf_in),
+     intermediate_output = tf_in,
+     dist = dist,
+     optimizer = keras::optimizer_adam(),
+     censoring = FALSE,
+     truncation = FALSE
+   )
+ }
> 
> 
> 
> 
> cleanEx()
> nameEx("tf_initialise_model")
> ### * tf_initialise_model
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tf_initialise_model
> ### Title: Initialise model weights to a global parameter fit
> ### Aliases: tf_initialise_model
> 
> ### ** Examples
> 
> dist <- dist_exponential()
> group <- sample(c(0, 1), size = 100, replace = TRUE)
> x <- dist$sample(100, with_params = list(rate = group + 1))
> global_fit <- fit(dist, x)
> 
> if (interactive() && keras::is_keras_available()) {
+   library(keras)
+   l_in <- layer_input(shape = 1L)
+   mod <- tf_compile_model(
+     inputs = list(l_in),
+     intermediate_output = l_in,
+     dist = dist,
+     optimizer = optimizer_adam(),
+     censoring = FALSE,
+     truncation = FALSE
+   )
+   tf_initialise_model(mod, global_fit$params)
+   fit_history <- fit(
+     mod,
+     x = group,
+     y = x,
+     epochs = 200L
+   )
+ 
+   predicted_means <- predict(mod, data = k_constant(c(0, 1)))
+ }
> 
> 
> 
> 
> cleanEx()
> nameEx("trunc_obs")
> ### * trunc_obs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trunc_obs
> ### Title: Define a set of truncated observations
> ### Aliases: trunc_obs as_trunc_obs truncate_obs repdel_obs
> 
> ### ** Examples
> 
> N <- 100
> x <- rexp(N, 0.5)
> 
> # Random, observation dependent truncation intervals
> tmin <- runif(N, 0, 1)
> tmax <- tmin + runif(N, 1, 2)
> 
> oob <- x < tmin | x > tmax
> x <- x[!oob]
> tmin <- tmin[!oob]
> tmax <- tmax[!oob]
> 
> # Number of observations after truncation
> N <- length(x)
> 
> # Randomly interval censor 30% of observations
> cens <- rbinom(N, 1, 0.3) == 1L
> xmin <- x
> xmax <- x
> xmin[cens] <- pmax(tmin[cens], floor(x[cens]))
> xmax[cens] <- pmin(tmax[cens], ceiling(x[cens]))
> x[cens] <- NA
> 
> trunc_obs(x, xmin, xmax, tmin, tmax)
# A tibble: 44 × 6
        x  xmin  xmax  tmin  tmax     w
    <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  0.872 0.872 0.872 0.548  1.77     1
 2 NA     1     2     0.101  2.08     1
 3 NA     1     2     0.927  2.25     1
 4  0.294 0.294 0.294 0.283  1.79     1
 5 NA     2     2.71  0.783  2.71     1
 6  1.31  1.31  1.31  0.517  2.01     1
 7  0.674 0.674 0.674 0.269  1.73     1
 8 NA     1     1.56  0.181  1.56     1
 9  1.28  1.28  1.28  0.563  1.74     1
10  0.588 0.588 0.588 0.129  1.94     1
# ℹ 34 more rows
> 
> as_trunc_obs(c(1, 2, 3))
# A tibble: 3 × 6
      x  xmin  xmax  tmin  tmax     w
  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
1     1     1     1  -Inf   Inf     1
2     2     2     2  -Inf   Inf     1
3     3     3     3  -Inf   Inf     1
> as_trunc_obs(data.frame(x = 1:3, tmin = 0, tmax = 10))
# A tibble: 3 × 6
      x  xmin  xmax  tmin  tmax     w
  <int> <int> <int> <dbl> <dbl> <dbl>
1     1     1     1     0    10     1
2     2     2     2     0    10     1
3     3     3     3     0    10     1
> as_trunc_obs(data.frame(x = c(1, NA), xmin = c(1, 2), xmax = c(1, 3)))
# A tibble: 2 × 6
      x  xmin  xmax  tmin  tmax     w
  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
1     1     1     1  -Inf   Inf     1
2    NA     2     3  -Inf   Inf     1
> truncate_obs(1:10, tmin_new = 2.0, tmax_new = 8.0)
# A tibble: 7 × 6
      x  xmin  xmax  tmin  tmax     w
  <int> <int> <int> <dbl> <dbl> <dbl>
1     2     2     2     2     8     1
2     3     3     3     2     8     1
3     4     4     4     2     8     1
4     5     5     5     2     8     1
5     6     6     6     2     8     1
6     7     7     7     2     8     1
7     8     8     8     2     8     1
> 
> 
> 
> cleanEx()
> nameEx("truncate_claims")
> ### * truncate_claims
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: truncate_claims
> ### Title: Truncate claims data subject to reporting delay
> ### Aliases: truncate_claims
> 
> ### ** Examples
> 
> claims_full <- data.frame(
+   acc = runif(100),
+   repdel = rexp(100)
+ )
> tau <- 2.0
> truncate_claims(claims_full, acc, repdel, tau)
          acc     repdel     report
1  0.26550866 0.30944786 0.57495652
2  0.37212390 1.10593627 1.47806017
3  0.57285336 0.77418776 1.34704113
4  0.90820779 0.08967408 0.99788187
5  0.20168193 1.10817666 1.30985859
6  0.89838968 0.24726425 1.14565394
9  0.62911404 0.43113213 1.06024618
11 0.20597457 1.13683142 1.34280599
12 0.17655675 0.81336825 0.98992500
13 0.68702285 0.83700649 1.52402934
17 0.71761851 0.28559098 1.00320949
18 0.99190609 0.38878677 1.38069287
19 0.38003518 0.05205545 0.43209063
20 0.77744522 0.35187050 1.12931572
22 0.21214252 0.81453581 1.02667833
24 0.12555510 0.38619356 0.51174866
25 0.26722067 1.00825646 1.27547713
26 0.38611409 0.81851419 1.20462828
27 0.01339033 0.05926121 0.07265154
29 0.86969085 0.80417091 1.67386176
30 0.34034900 1.58369608 1.92404508
31 0.48208012 1.23379151 1.71587162
32 0.59956583 1.34564402 1.94520984
34 0.18621760 1.03509715 1.22131475
35 0.82737332 0.44745189 1.27482521
36 0.66846674 1.04360851 1.71207525
37 0.79423986 0.26082824 1.05506811
38 0.10794363 0.68122911 0.78917273
39 0.72371095 0.26373826 0.98744921
40 0.41127443 0.44660565 0.85788008
41 0.82094629 0.21060689 1.03155319
42 0.64706019 0.13257141 0.77963160
43 0.78293276 0.34888835 1.13182111
45 0.52971958 0.51620610 1.04592568
46 0.78935623 0.44899779 1.23835402
47 0.02333120 0.37959969 0.40293089
48 0.47723007 1.24876758 1.72599764
50 0.69273156 0.19632181 0.88905337
52 0.86120948 0.56570267 1.42691215
53 0.43809711 0.76318001 1.20127712
54 0.24479728 1.57271671 1.81751398
55 0.07067905 1.83564098 1.90632003
56 0.09946616 0.03715227 0.13661844
57 0.31627171 0.12556587 0.44183758
58 0.51863426 1.41954920 1.93818346
59 0.66200508 0.71861760 1.38062267
60 0.40683019 0.43587055 0.84270074
61 0.91287592 0.06941235 0.98228827
62 0.29360337 0.21369196 0.50729533
63 0.45906573 0.29915892 0.75822465
64 0.33239467 0.23565563 0.56805030
65 0.65087047 0.74304362 1.39391409
66 0.25801678 1.70992583 1.96794261
67 0.47854525 0.98181941 1.46036466
68 0.76631067 0.02025041 0.78656108
69 0.08424691 0.17856945 0.26281636
71 0.33907294 1.36457221 1.70364515
72 0.83944035 0.09110887 0.93054922
73 0.34668349 1.19109464 1.53777813
74 0.33377493 0.26284046 0.59661539
75 0.47635125 1.25346292 1.72981416
76 0.89219834 0.37925570 1.27145403
77 0.86433947 0.37882682 1.24316630
78 0.38998954 0.10980125 0.49979079
79 0.77732070 0.90555746 1.68287816
80 0.96061800 0.15670789 1.11732589
81 0.43465948 0.09884562 0.53350510
83 0.39999437 0.78512086 1.18511523
84 0.32535215 0.52816003 0.85351219
85 0.75708715 1.02931641 1.78640356
87 0.71112122 1.18461401 1.89573524
88 0.12169192 0.21982794 0.34151986
89 0.24548851 0.80501130 1.05049981
90 0.14330438 0.57508102 0.71838539
91 0.23962942 0.40492503 0.64455444
92 0.05893438 1.70651547 1.76544985
94 0.87626921 0.50941124 1.38568046
95 0.77891468 0.24082007 1.01973474
99 0.81087024 0.72182727 1.53269751
> 
> 
> 
> 
> cleanEx()
> nameEx("weighted_moments")
> ### * weighted_moments
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: weighted_moments
> ### Title: Compute weighted moments
> ### Aliases: weighted_moments
> 
> ### ** Examples
> 
> weighted_moments(rexp(100))
[1] 1.0306764 0.8682287
> weighted_moments(c(1, 2, 3), c(1, 2, 3))
[1] 2.3333333 0.5555556
> c(mean(rep(1:3, 1:3)), var(rep(1:3, 1:3)) * 5 / 6)
[1] 2.3333333 0.5555556
> 
> 
> 
> cleanEx()
> nameEx("weighted_quantile")
> ### * weighted_quantile
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: weighted_quantile
> ### Title: Compute weighted quantiles
> ### Aliases: weighted_quantile weighted_median
> 
> ### ** Examples
> 
> weighted_median(1:6)
[1] 3.5
> weighted_median(1:3, c(1, 4, 9))
[1] 3
> weighted_median(1:3, c(9, 4, 1))
[1] 1
> 
> weighted_quantile(1:3, c(1, 4, 9), seq(0.0, 1.0, by = 0.25))
[1] 1 2 3 3 3
> quantile(rep(1:3, c(1, 4, 9)), seq(0.0, 1.0, by = 0.25))
  0%  25%  50%  75% 100% 
   1    2    3    3    3 
> 
> 
> 
> cleanEx()
> nameEx("weighted_tabulate")
> ### * weighted_tabulate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: weighted_tabulate
> ### Title: Compute weighted tabulations
> ### Aliases: weighted_tabulate
> 
> ### ** Examples
> 
> weighted_tabulate(c(1, 1, 2))
[1] 2 1
> weighted_tabulate(c(1, 1, 2), nbins = 3L)
[1] 2 1 0
> weighted_tabulate(c(1, 1, 2), w = c(0.5, 0.5, 1), nbins = 3L)
[1] 1 1 0
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  9.304 0.141 9.667 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
